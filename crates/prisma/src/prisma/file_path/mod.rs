// File generated by Prisma Client Rust. DO NOT EDIT

pub mod _count;
pub mod cas_id;
pub mod date_created;
pub mod date_indexed;
pub mod date_modified;
pub mod extension;
pub mod hidden;
pub mod id;
pub mod inode;
pub mod integrity_checksum;
pub mod is_dir;
pub mod key_id;
pub mod location;
pub mod location_id;
pub mod materialized_path;
pub mod name;
pub mod object;
pub mod object_id;
pub mod pub_id;
pub mod size_in_bytes;
pub mod size_in_bytes_bytes;
use super::{_prisma::*, *};
pub const NAME: &str = "FilePath";
pub fn location_id_materialized_path_name_extension<T: From<UniqueWhereParam>>(
	location_id: Int,
	materialized_path: String,
	name: String,
	extension: String,
) -> T {
	UniqueWhereParam::LocationIdMaterializedPathNameExtensionEquals(
		location_id,
		materialized_path,
		name,
		extension,
	)
	.into()
}
pub fn location_id_inode<T: From<UniqueWhereParam>>(location_id: Int, inode: Bytes) -> T {
	UniqueWhereParam::LocationIdInodeEquals(location_id, inode).into()
}
#[derive(Debug, Clone)]
pub enum WhereParam {
	Not(Vec<WhereParam>),
	Or(Vec<WhereParam>),
	And(Vec<WhereParam>),
	Id(super::_prisma::read_filters::IntFilter),
	PubId(super::_prisma::read_filters::BytesFilter),
	IsDir(super::_prisma::read_filters::BooleanNullableFilter),
	CasId(super::_prisma::read_filters::StringNullableFilter),
	IntegrityChecksum(super::_prisma::read_filters::StringNullableFilter),
	LocationId(super::_prisma::read_filters::IntNullableFilter),
	LocationIsNull,
	LocationIs(Vec<super::location::WhereParam>),
	LocationIsNot(Vec<super::location::WhereParam>),
	MaterializedPath(super::_prisma::read_filters::StringNullableFilter),
	Name(super::_prisma::read_filters::StringNullableFilter),
	Extension(super::_prisma::read_filters::StringNullableFilter),
	Hidden(super::_prisma::read_filters::BooleanNullableFilter),
	SizeInBytes(super::_prisma::read_filters::StringNullableFilter),
	SizeInBytesBytes(super::_prisma::read_filters::BytesNullableFilter),
	Inode(super::_prisma::read_filters::BytesNullableFilter),
	ObjectId(super::_prisma::read_filters::IntNullableFilter),
	ObjectIsNull,
	ObjectIs(Vec<super::object::WhereParam>),
	ObjectIsNot(Vec<super::object::WhereParam>),
	KeyId(super::_prisma::read_filters::IntNullableFilter),
	DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
	DateModified(super::_prisma::read_filters::DateTimeNullableFilter),
	DateIndexed(super::_prisma::read_filters::DateTimeNullableFilter),
}
impl ::prisma_client_rust::WhereInput for WhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			Self::Not(value) => (
				"NOT",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Or(value) => (
				"OR",
				::prisma_client_rust::SerializedWhereValue::List(
					value
						.into_iter()
						.map(::prisma_client_rust::WhereInput::serialize)
						.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
						.collect(),
				),
			),
			Self::And(value) => (
				"AND",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Id(value) => (id::NAME, value.into()),
			Self::PubId(value) => (pub_id::NAME, value.into()),
			Self::IsDir(value) => (is_dir::NAME, value.into()),
			Self::CasId(value) => (cas_id::NAME, value.into()),
			Self::IntegrityChecksum(value) => (integrity_checksum::NAME, value.into()),
			Self::LocationId(value) => (location_id::NAME, value.into()),
			Self::LocationIsNull => (
				location::NAME,
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Null,
				),
			),
			Self::LocationIs(where_params) => (
				location::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::LocationIsNot(where_params) => (
				location::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::MaterializedPath(value) => (materialized_path::NAME, value.into()),
			Self::Name(value) => (name::NAME, value.into()),
			Self::Extension(value) => (extension::NAME, value.into()),
			Self::Hidden(value) => (hidden::NAME, value.into()),
			Self::SizeInBytes(value) => (size_in_bytes::NAME, value.into()),
			Self::SizeInBytesBytes(value) => (size_in_bytes_bytes::NAME, value.into()),
			Self::Inode(value) => (inode::NAME, value.into()),
			Self::ObjectId(value) => (object_id::NAME, value.into()),
			Self::ObjectIsNull => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Null,
				),
			),
			Self::ObjectIs(where_params) => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ObjectIsNot(where_params) => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::KeyId(value) => (key_id::NAME, value.into()),
			Self::DateCreated(value) => (date_created::NAME, value.into()),
			Self::DateModified(value) => (date_modified::NAME, value.into()),
			Self::DateIndexed(value) => (date_indexed::NAME, value.into()),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
#[derive(Debug, Clone)]
pub enum UniqueWhereParam {
	PubIdEquals(Bytes),
	LocationIdMaterializedPathNameExtensionEquals(Int, String, String, String),
	LocationIdInodeEquals(Int, Bytes),
	IdEquals(Int),
}
impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			UniqueWhereParam::PubIdEquals(value) => (
				"pub_id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Bytes(value),
				),
			),
			Self::LocationIdMaterializedPathNameExtensionEquals(
				location_id,
				materialized_path,
				name,
				extension,
			) => (
				"location_id_materialized_path_name_extension",
				::prisma_client_rust::SerializedWhereValue::Object(vec![
					(
						location_id::NAME.to_string(),
						::prisma_client_rust::PrismaValue::Int(location_id),
					),
					(
						materialized_path::NAME.to_string(),
						::prisma_client_rust::PrismaValue::String(materialized_path),
					),
					(
						name::NAME.to_string(),
						::prisma_client_rust::PrismaValue::String(name),
					),
					(
						extension::NAME.to_string(),
						::prisma_client_rust::PrismaValue::String(extension),
					),
				]),
			),
			Self::LocationIdInodeEquals(location_id, inode) => (
				"location_id_inode",
				::prisma_client_rust::SerializedWhereValue::Object(vec![
					(
						location_id::NAME.to_string(),
						::prisma_client_rust::PrismaValue::Int(location_id),
					),
					(
						inode::NAME.to_string(),
						::prisma_client_rust::PrismaValue::Bytes(inode),
					),
				]),
			),
			UniqueWhereParam::IdEquals(value) => (
				"id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
	fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
		match op {
			::prisma_client_rust::Operator::Not(value) => Self::Not(value),
			::prisma_client_rust::Operator::And(value) => Self::And(value),
			::prisma_client_rust::Operator::Or(value) => Self::Or(value),
		}
	}
}
#[derive(Debug, Clone)]
pub enum OrderByWithRelationParam {
	Id(super::SortOrder),
	PubId(super::SortOrder),
	IsDir(super::SortOrder),
	CasId(super::SortOrder),
	IntegrityChecksum(super::SortOrder),
	LocationId(super::SortOrder),
	MaterializedPath(super::SortOrder),
	Name(super::SortOrder),
	Extension(super::SortOrder),
	Hidden(super::SortOrder),
	SizeInBytes(super::SortOrder),
	SizeInBytesBytes(super::SortOrder),
	Inode(super::SortOrder),
	ObjectId(super::SortOrder),
	KeyId(super::SortOrder),
	DateCreated(super::SortOrder),
	DateModified(super::SortOrder),
	DateIndexed(super::SortOrder),
	Location(Vec<super::location::OrderByWithRelationParam>),
	Object(Vec<super::object::OrderByWithRelationParam>),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(param) => ("id", param.into()),
			Self::PubId(param) => ("pub_id", param.into()),
			Self::IsDir(param) => ("is_dir", param.into()),
			Self::CasId(param) => ("cas_id", param.into()),
			Self::IntegrityChecksum(param) => ("integrity_checksum", param.into()),
			Self::LocationId(param) => ("location_id", param.into()),
			Self::MaterializedPath(param) => ("materialized_path", param.into()),
			Self::Name(param) => ("name", param.into()),
			Self::Extension(param) => ("extension", param.into()),
			Self::Hidden(param) => ("hidden", param.into()),
			Self::SizeInBytes(param) => ("size_in_bytes", param.into()),
			Self::SizeInBytesBytes(param) => ("size_in_bytes_bytes", param.into()),
			Self::Inode(param) => ("inode", param.into()),
			Self::ObjectId(param) => ("object_id", param.into()),
			Self::KeyId(param) => ("key_id", param.into()),
			Self::DateCreated(param) => ("date_created", param.into()),
			Self::DateModified(param) => ("date_modified", param.into()),
			Self::DateIndexed(param) => ("date_indexed", param.into()),
			Self::Location(param) => (
				"location",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::Object(param) => (
				"object",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum OrderByRelationAggregateParam {
	_Count(super::SortOrder),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByRelationAggregateParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::_Count(param) => ("_count", param.into()),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum WithParam {
	Location(super::location::UniqueArgs),
	Object(super::object::UniqueArgs),
}
impl Into<::prisma_client_rust::Selection> for WithParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Location(args) => {
				let mut selections =
					<super::location::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(
					);
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(location::NAME, None, [], selections)
			}
			Self::Object(args) => {
				let mut selections =
					<super::object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
			}
		}
	}
}
#[derive(Debug, Clone)]
pub enum SetParam {
	Id(super::_prisma::write_params::IntParam),
	PubId(super::_prisma::write_params::BytesParam),
	IsDir(super::_prisma::write_params::BooleanNullableParam),
	CasId(super::_prisma::write_params::StringNullableParam),
	IntegrityChecksum(super::_prisma::write_params::StringNullableParam),
	LocationId(super::_prisma::write_params::IntNullableParam),
	ConnectLocation(super::location::UniqueWhereParam),
	DisconnectLocation,
	MaterializedPath(super::_prisma::write_params::StringNullableParam),
	Name(super::_prisma::write_params::StringNullableParam),
	Extension(super::_prisma::write_params::StringNullableParam),
	Hidden(super::_prisma::write_params::BooleanNullableParam),
	SizeInBytes(super::_prisma::write_params::StringNullableParam),
	SizeInBytesBytes(super::_prisma::write_params::BytesNullableParam),
	Inode(super::_prisma::write_params::BytesNullableParam),
	ObjectId(super::_prisma::write_params::IntNullableParam),
	ConnectObject(super::object::UniqueWhereParam),
	DisconnectObject,
	KeyId(super::_prisma::write_params::IntNullableParam),
	DateCreated(super::_prisma::write_params::DateTimeNullableParam),
	DateModified(super::_prisma::write_params::DateTimeNullableParam),
	DateIndexed(super::_prisma::write_params::DateTimeNullableParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => (id::NAME, value.into()),
			Self::PubId(value) => (pub_id::NAME, value.into()),
			Self::IsDir(value) => (is_dir::NAME, value.into()),
			Self::CasId(value) => (cas_id::NAME, value.into()),
			Self::IntegrityChecksum(value) => (integrity_checksum::NAME, value.into()),
			Self::LocationId(value) => (location_id::NAME, value.into()),
			Self::ConnectLocation(where_param) => (
				location::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::DisconnectLocation => (
				location::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(true),
				)]),
			),
			Self::MaterializedPath(value) => (materialized_path::NAME, value.into()),
			Self::Name(value) => (name::NAME, value.into()),
			Self::Extension(value) => (extension::NAME, value.into()),
			Self::Hidden(value) => (hidden::NAME, value.into()),
			Self::SizeInBytes(value) => (size_in_bytes::NAME, value.into()),
			Self::SizeInBytesBytes(value) => (size_in_bytes_bytes::NAME, value.into()),
			Self::Inode(value) => (inode::NAME, value.into()),
			Self::ObjectId(value) => (object_id::NAME, value.into()),
			Self::ConnectObject(where_param) => (
				object::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::DisconnectObject => (
				object::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(true),
				)]),
			),
			Self::KeyId(value) => (key_id::NAME, value.into()),
			Self::DateCreated(value) => (date_created::NAME, value.into()),
			Self::DateModified(value) => (date_modified::NAME, value.into()),
			Self::DateIndexed(value) => (date_indexed::NAME, value.into()),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum UncheckedSetParam {
	Id(super::_prisma::write_params::IntParam),
	PubId(super::_prisma::write_params::BytesParam),
	IsDir(super::_prisma::write_params::BooleanNullableParam),
	CasId(super::_prisma::write_params::StringNullableParam),
	IntegrityChecksum(super::_prisma::write_params::StringNullableParam),
	LocationId(super::_prisma::write_params::IntNullableParam),
	MaterializedPath(super::_prisma::write_params::StringNullableParam),
	Name(super::_prisma::write_params::StringNullableParam),
	Extension(super::_prisma::write_params::StringNullableParam),
	Hidden(super::_prisma::write_params::BooleanNullableParam),
	SizeInBytes(super::_prisma::write_params::StringNullableParam),
	SizeInBytesBytes(super::_prisma::write_params::BytesNullableParam),
	Inode(super::_prisma::write_params::BytesNullableParam),
	ObjectId(super::_prisma::write_params::IntNullableParam),
	KeyId(super::_prisma::write_params::IntNullableParam),
	DateCreated(super::_prisma::write_params::DateTimeNullableParam),
	DateModified(super::_prisma::write_params::DateTimeNullableParam),
	DateIndexed(super::_prisma::write_params::DateTimeNullableParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => ("id", value.into()),
			Self::PubId(value) => ("pub_id", value.into()),
			Self::IsDir(value) => ("is_dir", value.into()),
			Self::CasId(value) => ("cas_id", value.into()),
			Self::IntegrityChecksum(value) => ("integrity_checksum", value.into()),
			Self::LocationId(value) => ("location_id", value.into()),
			Self::MaterializedPath(value) => ("materialized_path", value.into()),
			Self::Name(value) => ("name", value.into()),
			Self::Extension(value) => ("extension", value.into()),
			Self::Hidden(value) => ("hidden", value.into()),
			Self::SizeInBytes(value) => ("size_in_bytes", value.into()),
			Self::SizeInBytesBytes(value) => ("size_in_bytes_bytes", value.into()),
			Self::Inode(value) => ("inode", value.into()),
			Self::ObjectId(value) => ("object_id", value.into()),
			Self::KeyId(value) => ("key_id", value.into()),
			Self::DateCreated(value) => ("date_created", value.into()),
			Self::DateModified(value) => ("date_modified", value.into()),
			Self::DateIndexed(value) => ("date_indexed", value.into()),
		};
		(k.to_string(), v)
	}
}
::prisma_client_rust::macros::select_factory!(
	_select_file_path,
	select,
	prisma::file_path,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "pub_id")]
		pub_id: pub_id::Type,
		#[serde(rename = "is_dir")]
		is_dir: is_dir::Type,
		#[serde(rename = "cas_id")]
		cas_id: cas_id::Type,
		#[serde(rename = "integrity_checksum")]
		integrity_checksum: integrity_checksum::Type,
		#[serde(rename = "location_id")]
		location_id: location_id::Type,
		#[serde(rename = "location")]
		location: location::Type,
		#[serde(rename = "materialized_path")]
		materialized_path: materialized_path::Type,
		#[serde(rename = "name")]
		name: name::Type,
		#[serde(rename = "extension")]
		extension: extension::Type,
		#[serde(rename = "hidden")]
		hidden: hidden::Type,
		#[serde(rename = "size_in_bytes")]
		size_in_bytes: size_in_bytes::Type,
		#[serde(rename = "size_in_bytes_bytes")]
		size_in_bytes_bytes: size_in_bytes_bytes::Type,
		#[serde(rename = "inode")]
		inode: inode::Type,
		#[serde(rename = "object_id")]
		object_id: object_id::Type,
		#[serde(rename = "object")]
		object: object::Type,
		#[serde(rename = "key_id")]
		key_id: key_id::Type,
		#[serde(rename = "date_created")]
		date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		date_modified: date_modified::Type,
		#[serde(rename = "date_indexed")]
		date_indexed: date_indexed::Type,
	},
	[
		(id, Scalar),
		(pub_id, Scalar),
		(is_dir, Scalar),
		(cas_id, Scalar),
		(integrity_checksum, Scalar),
		(location_id, Scalar),
		(location, Relation(prisma::location, Optional)),
		(materialized_path, Scalar),
		(name, Scalar),
		(extension, Scalar),
		(hidden, Scalar),
		(size_in_bytes, Scalar),
		(size_in_bytes_bytes, Scalar),
		(inode, Scalar),
		(object_id, Scalar),
		(object, Relation(prisma::object, Optional)),
		(key_id, Scalar),
		(date_created, Scalar),
		(date_modified, Scalar),
		(date_indexed, Scalar)
	]
);
pub enum SelectParam {
	Id(id::Select),
	PubId(pub_id::Select),
	IsDir(is_dir::Select),
	CasId(cas_id::Select),
	IntegrityChecksum(integrity_checksum::Select),
	LocationId(location_id::Select),
	Location(location::Select),
	MaterializedPath(materialized_path::Select),
	Name(name::Select),
	Extension(extension::Select),
	Hidden(hidden::Select),
	SizeInBytes(size_in_bytes::Select),
	SizeInBytesBytes(size_in_bytes_bytes::Select),
	Inode(inode::Select),
	ObjectId(object_id::Select),
	Object(object::Select),
	KeyId(key_id::Select),
	DateCreated(date_created::Select),
	DateModified(date_modified::Select),
	DateIndexed(date_indexed::Select),
}
impl Into<::prisma_client_rust::Selection> for SelectParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::PubId(data) => data.into(),
			Self::IsDir(data) => data.into(),
			Self::CasId(data) => data.into(),
			Self::IntegrityChecksum(data) => data.into(),
			Self::LocationId(data) => data.into(),
			Self::Location(data) => data.into(),
			Self::MaterializedPath(data) => data.into(),
			Self::Name(data) => data.into(),
			Self::Extension(data) => data.into(),
			Self::Hidden(data) => data.into(),
			Self::SizeInBytes(data) => data.into(),
			Self::SizeInBytesBytes(data) => data.into(),
			Self::Inode(data) => data.into(),
			Self::ObjectId(data) => data.into(),
			Self::Object(data) => data.into(),
			Self::KeyId(data) => data.into(),
			Self::DateCreated(data) => data.into(),
			Self::DateModified(data) => data.into(),
			Self::DateIndexed(data) => data.into(),
		}
	}
}
::prisma_client_rust::macros::include_factory!(
	_include_file_path,
	include,
	prisma::file_path,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "pub_id")]
		pub_id: pub_id::Type,
		#[serde(rename = "is_dir")]
		is_dir: is_dir::Type,
		#[serde(rename = "cas_id")]
		cas_id: cas_id::Type,
		#[serde(rename = "integrity_checksum")]
		integrity_checksum: integrity_checksum::Type,
		#[serde(rename = "location_id")]
		location_id: location_id::Type,
		#[serde(rename = "location")]
		location: location::Type,
		#[serde(rename = "materialized_path")]
		materialized_path: materialized_path::Type,
		#[serde(rename = "name")]
		name: name::Type,
		#[serde(rename = "extension")]
		extension: extension::Type,
		#[serde(rename = "hidden")]
		hidden: hidden::Type,
		#[serde(rename = "size_in_bytes")]
		size_in_bytes: size_in_bytes::Type,
		#[serde(rename = "size_in_bytes_bytes")]
		size_in_bytes_bytes: size_in_bytes_bytes::Type,
		#[serde(rename = "inode")]
		inode: inode::Type,
		#[serde(rename = "object_id")]
		object_id: object_id::Type,
		#[serde(rename = "object")]
		object: object::Type,
		#[serde(rename = "key_id")]
		key_id: key_id::Type,
		#[serde(rename = "date_created")]
		date_created: date_created::Type,
		#[serde(rename = "date_modified")]
		date_modified: date_modified::Type,
		#[serde(rename = "date_indexed")]
		date_indexed: date_indexed::Type,
	},
	[
		(location, Relation(prisma::location, Optional)),
		(object, Relation(prisma::object, Optional))
	]
);
pub enum IncludeParam {
	Id(id::Include),
	PubId(pub_id::Include),
	IsDir(is_dir::Include),
	CasId(cas_id::Include),
	IntegrityChecksum(integrity_checksum::Include),
	LocationId(location_id::Include),
	Location(location::Include),
	MaterializedPath(materialized_path::Include),
	Name(name::Include),
	Extension(extension::Include),
	Hidden(hidden::Include),
	SizeInBytes(size_in_bytes::Include),
	SizeInBytesBytes(size_in_bytes_bytes::Include),
	Inode(inode::Include),
	ObjectId(object_id::Include),
	Object(object::Include),
	KeyId(key_id::Include),
	DateCreated(date_created::Include),
	DateModified(date_modified::Include),
	DateIndexed(date_indexed::Include),
}
impl Into<::prisma_client_rust::Selection> for IncludeParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::PubId(data) => data.into(),
			Self::IsDir(data) => data.into(),
			Self::CasId(data) => data.into(),
			Self::IntegrityChecksum(data) => data.into(),
			Self::LocationId(data) => data.into(),
			Self::Location(data) => data.into(),
			Self::MaterializedPath(data) => data.into(),
			Self::Name(data) => data.into(),
			Self::Extension(data) => data.into(),
			Self::Hidden(data) => data.into(),
			Self::SizeInBytes(data) => data.into(),
			Self::SizeInBytesBytes(data) => data.into(),
			Self::Inode(data) => data.into(),
			Self::ObjectId(data) => data.into(),
			Self::Object(data) => data.into(),
			Self::KeyId(data) => data.into(),
			Self::DateCreated(data) => data.into(),
			Self::DateModified(data) => data.into(),
			Self::DateIndexed(data) => data.into(),
		}
	}
}
#[derive(Debug, Clone)]
pub struct Create {
	pub pub_id: Bytes,
	pub _params: Vec<SetParam>,
}
impl Create {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
		client.file_path().create(self.pub_id, self._params)
	}
	pub fn to_params(mut self) -> Vec<SetParam> {
		self._params.extend([pub_id::set(self.pub_id)]);
		self._params
	}
}
pub fn create(pub_id: Bytes, _params: Vec<SetParam>) -> Create {
	Create { pub_id, _params }
}
#[derive(Debug, Clone)]
pub struct CreateUnchecked {
	pub pub_id: Bytes,
	pub _params: Vec<UncheckedSetParam>,
}
impl CreateUnchecked {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
		client
			.file_path()
			.create_unchecked(self.pub_id, self._params)
	}
	pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
		self._params.extend([pub_id::set(self.pub_id)]);
		self._params
	}
}
pub fn create_unchecked(pub_id: Bytes, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
	CreateUnchecked { pub_id, _params }
}
#[derive(Debug, Clone)]
pub struct Types;
impl ::prisma_client_rust::ModelTypes for Types {
	type Data = Data;
	type Where = WhereParam;
	type WhereUnique = UniqueWhereParam;
	type UncheckedSet = UncheckedSetParam;
	type Set = SetParam;
	type With = WithParam;
	type OrderBy = OrderByWithRelationParam;
	type Cursor = UniqueWhereParam;
	const MODEL: &'static str = NAME;
	fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
		vec![
			::prisma_client_rust::sel(id::NAME),
			::prisma_client_rust::sel(pub_id::NAME),
			::prisma_client_rust::sel(is_dir::NAME),
			::prisma_client_rust::sel(cas_id::NAME),
			::prisma_client_rust::sel(integrity_checksum::NAME),
			::prisma_client_rust::sel(location_id::NAME),
			::prisma_client_rust::sel(materialized_path::NAME),
			::prisma_client_rust::sel(name::NAME),
			::prisma_client_rust::sel(extension::NAME),
			::prisma_client_rust::sel(hidden::NAME),
			::prisma_client_rust::sel(size_in_bytes::NAME),
			::prisma_client_rust::sel(size_in_bytes_bytes::NAME),
			::prisma_client_rust::sel(inode::NAME),
			::prisma_client_rust::sel(object_id::NAME),
			::prisma_client_rust::sel(key_id::NAME),
			::prisma_client_rust::sel(date_created::NAME),
			::prisma_client_rust::sel(date_modified::NAME),
			::prisma_client_rust::sel(date_indexed::NAME),
		]
	}
}
#[derive(
	Debug,
	Clone,
	:: serde :: Serialize,
	:: serde :: Deserialize,
	:: prisma_client_rust :: specta :: Type,
)]
# [specta (rename = "FilePath" , crate = prisma_client_rust :: specta)]
pub struct Data {
	#[serde(rename = "id")]
	pub id: id::Type,
	#[serde(rename = "pub_id")]
	pub pub_id: pub_id::Type,
	#[serde(rename = "is_dir")]
	pub is_dir: is_dir::Type,
	#[serde(rename = "cas_id")]
	pub cas_id: cas_id::Type,
	#[serde(rename = "integrity_checksum")]
	pub integrity_checksum: integrity_checksum::Type,
	#[serde(rename = "location_id")]
	pub location_id: location_id::Type,
	#[serde(
		rename = "location",
		default,
		skip_serializing_if = "Option::is_none",
		with = "prisma_client_rust::serde::double_option"
	)]
	#[specta(skip)]
	pub location: Option<location::RecursiveSafeType>,
	#[serde(rename = "materialized_path")]
	pub materialized_path: materialized_path::Type,
	#[serde(rename = "name")]
	pub name: name::Type,
	#[serde(rename = "extension")]
	pub extension: extension::Type,
	#[serde(rename = "hidden")]
	pub hidden: hidden::Type,
	#[serde(rename = "size_in_bytes")]
	pub size_in_bytes: size_in_bytes::Type,
	#[serde(rename = "size_in_bytes_bytes")]
	pub size_in_bytes_bytes: size_in_bytes_bytes::Type,
	#[serde(rename = "inode")]
	pub inode: inode::Type,
	#[serde(rename = "object_id")]
	pub object_id: object_id::Type,
	#[serde(
		rename = "object",
		default,
		skip_serializing_if = "Option::is_none",
		with = "prisma_client_rust::serde::double_option"
	)]
	#[specta(skip)]
	pub object: Option<object::RecursiveSafeType>,
	#[serde(rename = "key_id")]
	pub key_id: key_id::Type,
	#[serde(rename = "date_created")]
	pub date_created: date_created::Type,
	#[serde(rename = "date_modified")]
	pub date_modified: date_modified::Type,
	#[serde(rename = "date_indexed")]
	pub date_indexed: date_indexed::Type,
}
impl Data {
	pub fn location(
		&self,
	) -> Result<Option<&super::location::Data>, ::prisma_client_rust::RelationNotFetchedError> {
		self.location
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(location),
			))
			.map(|v| v.as_ref().map(|v| v.as_ref()))
	}
	pub fn object(
		&self,
	) -> Result<Option<&super::object::Data>, ::prisma_client_rust::RelationNotFetchedError> {
		self.object
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(object),
			))
			.map(|v| v.as_ref().map(|v| v.as_ref()))
	}
}
::prisma_client_rust::macros::partial_unchecked_factory!(
	_partial_unchecked_file_path,
	prisma::file_path,
	struct Data {
		#[serde(rename = "id")]
		pub id: prisma::file_path::id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: prisma::file_path::pub_id::Type,
		#[serde(rename = "is_dir")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub is_dir: prisma::file_path::is_dir::Type,
		#[serde(rename = "cas_id")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub cas_id: prisma::file_path::cas_id::Type,
		#[serde(rename = "integrity_checksum")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub integrity_checksum: prisma::file_path::integrity_checksum::Type,
		#[serde(rename = "location_id")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub location_id: prisma::file_path::location_id::Type,
		#[serde(rename = "materialized_path")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub materialized_path: prisma::file_path::materialized_path::Type,
		#[serde(rename = "name")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub name: prisma::file_path::name::Type,
		#[serde(rename = "extension")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub extension: prisma::file_path::extension::Type,
		#[serde(rename = "hidden")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub hidden: prisma::file_path::hidden::Type,
		#[serde(rename = "size_in_bytes")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub size_in_bytes: prisma::file_path::size_in_bytes::Type,
		#[serde(rename = "size_in_bytes_bytes")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub size_in_bytes_bytes: prisma::file_path::size_in_bytes_bytes::Type,
		#[serde(rename = "inode")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub inode: prisma::file_path::inode::Type,
		#[serde(rename = "object_id")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub object_id: prisma::file_path::object_id::Type,
		#[serde(rename = "key_id")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub key_id: prisma::file_path::key_id::Type,
		#[serde(rename = "date_created")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub date_created: prisma::file_path::date_created::Type,
		#[serde(rename = "date_modified")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub date_modified: prisma::file_path::date_modified::Type,
		#[serde(rename = "date_indexed")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub date_indexed: prisma::file_path::date_indexed::Type,
	}
);
::prisma_client_rust::macros::filter_factory!(
	_file_path_filter,
	prisma::file_path,
	[
		(id, Scalar),
		(pub_id, Scalar),
		(is_dir, Scalar),
		(cas_id, Scalar),
		(integrity_checksum, Scalar),
		(location_id, Scalar),
		(location, Relation(prisma::location, Optional)),
		(materialized_path, Scalar),
		(name, Scalar),
		(extension, Scalar),
		(hidden, Scalar),
		(size_in_bytes, Scalar),
		(size_in_bytes_bytes, Scalar),
		(inode, Scalar),
		(object_id, Scalar),
		(object, Relation(prisma::object, Optional)),
		(key_id, Scalar),
		(date_created, Scalar),
		(date_modified, Scalar),
		(date_indexed, Scalar)
	]
);
pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
#[derive(Clone)]
pub struct Actions<'a> {
	pub client: &'a ::prisma_client_rust::PrismaClientInternals,
}
impl<'a> Actions<'a> {
	pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
		FindUniqueQuery::new(self.client, _where)
	}
	pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
		FindFirstQuery::new(self.client, _where)
	}
	pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
		FindManyQuery::new(self.client, _where)
	}
	pub fn create(self, pub_id: Bytes, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
		_params.extend([pub_id::set(pub_id)]);
		CreateQuery::new(self.client, _params)
	}
	pub fn create_unchecked(
		self,
		pub_id: Bytes,
		mut _params: Vec<UncheckedSetParam>,
	) -> CreateUncheckedQuery<'a> {
		_params.extend([pub_id::set(pub_id)]);
		CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
	}
	pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
		let data = data.into_iter().map(CreateUnchecked::to_params).collect();
		CreateManyQuery::new(self.client, data)
	}
	pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
		UpdateQuery::new(self.client, _where, _params, vec![])
	}
	pub fn update_unchecked(
		self,
		_where: UniqueWhereParam,
		_params: Vec<UncheckedSetParam>,
	) -> UpdateUncheckedQuery<'a> {
		UpdateUncheckedQuery::new(
			self.client,
			_where,
			_params.into_iter().map(Into::into).collect(),
			vec![],
		)
	}
	pub fn update_many(
		self,
		_where: Vec<WhereParam>,
		_params: Vec<SetParam>,
	) -> UpdateManyQuery<'a> {
		UpdateManyQuery::new(self.client, _where, _params)
	}
	pub fn upsert(
		self,
		_where: UniqueWhereParam,
		_create: Create,
		_update: Vec<SetParam>,
	) -> UpsertQuery<'a> {
		UpsertQuery::new(self.client, _where, _create.to_params(), _update)
	}
	pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
		DeleteQuery::new(self.client, _where, vec![])
	}
	pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
		DeleteManyQuery::new(self.client, _where)
	}
	pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
		CountQuery::new(self.client, _where)
	}
}
