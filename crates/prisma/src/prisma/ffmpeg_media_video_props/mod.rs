// File generated by Prisma Client Rust. DO NOT EDIT

pub mod aspect_ratio_den;
pub mod aspect_ratio_num;
pub mod bits_per_channel;
pub mod chroma_location;
pub mod codec;
pub mod codec_id;
pub mod color_primaries;
pub mod color_range;
pub mod color_space;
pub mod color_transfer;
pub mod field_order;
pub mod height;
pub mod id;
pub mod pixel_format;
pub mod properties;
pub mod width;
use super::{_prisma::*, *};
pub const NAME: &str = "FfmpegMediaVideoProps";
#[derive(Debug, Clone)]
pub enum WhereParam {
	Not(Vec<WhereParam>),
	Or(Vec<WhereParam>),
	And(Vec<WhereParam>),
	Id(super::_prisma::read_filters::IntFilter),
	PixelFormat(super::_prisma::read_filters::StringNullableFilter),
	ColorRange(super::_prisma::read_filters::StringNullableFilter),
	BitsPerChannel(super::_prisma::read_filters::IntNullableFilter),
	ColorSpace(super::_prisma::read_filters::StringNullableFilter),
	ColorPrimaries(super::_prisma::read_filters::StringNullableFilter),
	ColorTransfer(super::_prisma::read_filters::StringNullableFilter),
	FieldOrder(super::_prisma::read_filters::StringNullableFilter),
	ChromaLocation(super::_prisma::read_filters::StringNullableFilter),
	Width(super::_prisma::read_filters::IntFilter),
	Height(super::_prisma::read_filters::IntFilter),
	AspectRatioNum(super::_prisma::read_filters::IntNullableFilter),
	AspectRatioDen(super::_prisma::read_filters::IntNullableFilter),
	Properties(super::_prisma::read_filters::StringNullableFilter),
	CodecIs(Vec<super::ffmpeg_media_codec::WhereParam>),
	CodecIsNot(Vec<super::ffmpeg_media_codec::WhereParam>),
	CodecId(super::_prisma::read_filters::IntFilter),
}
impl ::prisma_client_rust::WhereInput for WhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			Self::Not(value) => (
				"NOT",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Or(value) => (
				"OR",
				::prisma_client_rust::SerializedWhereValue::List(
					value
						.into_iter()
						.map(::prisma_client_rust::WhereInput::serialize)
						.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
						.collect(),
				),
			),
			Self::And(value) => (
				"AND",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Id(value) => (id::NAME, value.into()),
			Self::PixelFormat(value) => (pixel_format::NAME, value.into()),
			Self::ColorRange(value) => (color_range::NAME, value.into()),
			Self::BitsPerChannel(value) => (bits_per_channel::NAME, value.into()),
			Self::ColorSpace(value) => (color_space::NAME, value.into()),
			Self::ColorPrimaries(value) => (color_primaries::NAME, value.into()),
			Self::ColorTransfer(value) => (color_transfer::NAME, value.into()),
			Self::FieldOrder(value) => (field_order::NAME, value.into()),
			Self::ChromaLocation(value) => (chroma_location::NAME, value.into()),
			Self::Width(value) => (width::NAME, value.into()),
			Self::Height(value) => (height::NAME, value.into()),
			Self::AspectRatioNum(value) => (aspect_ratio_num::NAME, value.into()),
			Self::AspectRatioDen(value) => (aspect_ratio_den::NAME, value.into()),
			Self::Properties(value) => (properties::NAME, value.into()),
			Self::CodecIs(where_params) => (
				codec::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::CodecIsNot(where_params) => (
				codec::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::CodecId(value) => (codec_id::NAME, value.into()),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
#[derive(Debug, Clone)]
pub enum UniqueWhereParam {
	CodecIdEquals(Int),
	IdEquals(Int),
}
impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			UniqueWhereParam::CodecIdEquals(value) => (
				"codec_id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
			UniqueWhereParam::IdEquals(value) => (
				"id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
	fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
		match op {
			::prisma_client_rust::Operator::Not(value) => Self::Not(value),
			::prisma_client_rust::Operator::And(value) => Self::And(value),
			::prisma_client_rust::Operator::Or(value) => Self::Or(value),
		}
	}
}
#[derive(Debug, Clone)]
pub enum OrderByWithRelationParam {
	Id(super::SortOrder),
	PixelFormat(super::SortOrder),
	ColorRange(super::SortOrder),
	BitsPerChannel(super::SortOrder),
	ColorSpace(super::SortOrder),
	ColorPrimaries(super::SortOrder),
	ColorTransfer(super::SortOrder),
	FieldOrder(super::SortOrder),
	ChromaLocation(super::SortOrder),
	Width(super::SortOrder),
	Height(super::SortOrder),
	AspectRatioNum(super::SortOrder),
	AspectRatioDen(super::SortOrder),
	Properties(super::SortOrder),
	CodecId(super::SortOrder),
	Codec(Vec<super::ffmpeg_media_codec::OrderByWithRelationParam>),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(param) => ("id", param.into()),
			Self::PixelFormat(param) => ("pixel_format", param.into()),
			Self::ColorRange(param) => ("color_range", param.into()),
			Self::BitsPerChannel(param) => ("bits_per_channel", param.into()),
			Self::ColorSpace(param) => ("color_space", param.into()),
			Self::ColorPrimaries(param) => ("color_primaries", param.into()),
			Self::ColorTransfer(param) => ("color_transfer", param.into()),
			Self::FieldOrder(param) => ("field_order", param.into()),
			Self::ChromaLocation(param) => ("chroma_location", param.into()),
			Self::Width(param) => ("width", param.into()),
			Self::Height(param) => ("height", param.into()),
			Self::AspectRatioNum(param) => ("aspect_ratio_num", param.into()),
			Self::AspectRatioDen(param) => ("aspect_ratio_Den", param.into()),
			Self::Properties(param) => ("properties", param.into()),
			Self::CodecId(param) => ("codec_id", param.into()),
			Self::Codec(param) => (
				"codec",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum WithParam {
	Codec(super::ffmpeg_media_codec::UniqueArgs),
}
impl Into<::prisma_client_rust::Selection> for WithParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Codec(args) => {
				let mut selections = < super :: ffmpeg_media_codec :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(codec::NAME, None, [], selections)
			}
		}
	}
}
#[derive(Debug, Clone)]
pub enum SetParam {
	Id(super::_prisma::write_params::IntParam),
	PixelFormat(super::_prisma::write_params::StringNullableParam),
	ColorRange(super::_prisma::write_params::StringNullableParam),
	BitsPerChannel(super::_prisma::write_params::IntNullableParam),
	ColorSpace(super::_prisma::write_params::StringNullableParam),
	ColorPrimaries(super::_prisma::write_params::StringNullableParam),
	ColorTransfer(super::_prisma::write_params::StringNullableParam),
	FieldOrder(super::_prisma::write_params::StringNullableParam),
	ChromaLocation(super::_prisma::write_params::StringNullableParam),
	Width(super::_prisma::write_params::IntParam),
	Height(super::_prisma::write_params::IntParam),
	AspectRatioNum(super::_prisma::write_params::IntNullableParam),
	AspectRatioDen(super::_prisma::write_params::IntNullableParam),
	Properties(super::_prisma::write_params::StringNullableParam),
	ConnectCodec(super::ffmpeg_media_codec::UniqueWhereParam),
	CodecId(super::_prisma::write_params::IntParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => (id::NAME, value.into()),
			Self::PixelFormat(value) => (pixel_format::NAME, value.into()),
			Self::ColorRange(value) => (color_range::NAME, value.into()),
			Self::BitsPerChannel(value) => (bits_per_channel::NAME, value.into()),
			Self::ColorSpace(value) => (color_space::NAME, value.into()),
			Self::ColorPrimaries(value) => (color_primaries::NAME, value.into()),
			Self::ColorTransfer(value) => (color_transfer::NAME, value.into()),
			Self::FieldOrder(value) => (field_order::NAME, value.into()),
			Self::ChromaLocation(value) => (chroma_location::NAME, value.into()),
			Self::Width(value) => (width::NAME, value.into()),
			Self::Height(value) => (height::NAME, value.into()),
			Self::AspectRatioNum(value) => (aspect_ratio_num::NAME, value.into()),
			Self::AspectRatioDen(value) => (aspect_ratio_den::NAME, value.into()),
			Self::Properties(value) => (properties::NAME, value.into()),
			Self::ConnectCodec(where_param) => (
				codec::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::CodecId(value) => (codec_id::NAME, value.into()),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum UncheckedSetParam {
	Id(super::_prisma::write_params::IntParam),
	PixelFormat(super::_prisma::write_params::StringNullableParam),
	ColorRange(super::_prisma::write_params::StringNullableParam),
	BitsPerChannel(super::_prisma::write_params::IntNullableParam),
	ColorSpace(super::_prisma::write_params::StringNullableParam),
	ColorPrimaries(super::_prisma::write_params::StringNullableParam),
	ColorTransfer(super::_prisma::write_params::StringNullableParam),
	FieldOrder(super::_prisma::write_params::StringNullableParam),
	ChromaLocation(super::_prisma::write_params::StringNullableParam),
	Width(super::_prisma::write_params::IntParam),
	Height(super::_prisma::write_params::IntParam),
	AspectRatioNum(super::_prisma::write_params::IntNullableParam),
	AspectRatioDen(super::_prisma::write_params::IntNullableParam),
	Properties(super::_prisma::write_params::StringNullableParam),
	CodecId(super::_prisma::write_params::IntParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => ("id", value.into()),
			Self::PixelFormat(value) => ("pixel_format", value.into()),
			Self::ColorRange(value) => ("color_range", value.into()),
			Self::BitsPerChannel(value) => ("bits_per_channel", value.into()),
			Self::ColorSpace(value) => ("color_space", value.into()),
			Self::ColorPrimaries(value) => ("color_primaries", value.into()),
			Self::ColorTransfer(value) => ("color_transfer", value.into()),
			Self::FieldOrder(value) => ("field_order", value.into()),
			Self::ChromaLocation(value) => ("chroma_location", value.into()),
			Self::Width(value) => ("width", value.into()),
			Self::Height(value) => ("height", value.into()),
			Self::AspectRatioNum(value) => ("aspect_ratio_num", value.into()),
			Self::AspectRatioDen(value) => ("aspect_ratio_Den", value.into()),
			Self::Properties(value) => ("properties", value.into()),
			Self::CodecId(value) => ("codec_id", value.into()),
		};
		(k.to_string(), v)
	}
}
::prisma_client_rust::macros::select_factory!(
	_select_ffmpeg_media_video_props,
	select,
	prisma::ffmpeg_media_video_props,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "pixel_format")]
		pixel_format: pixel_format::Type,
		#[serde(rename = "color_range")]
		color_range: color_range::Type,
		#[serde(rename = "bits_per_channel")]
		bits_per_channel: bits_per_channel::Type,
		#[serde(rename = "color_space")]
		color_space: color_space::Type,
		#[serde(rename = "color_primaries")]
		color_primaries: color_primaries::Type,
		#[serde(rename = "color_transfer")]
		color_transfer: color_transfer::Type,
		#[serde(rename = "field_order")]
		field_order: field_order::Type,
		#[serde(rename = "chroma_location")]
		chroma_location: chroma_location::Type,
		#[serde(rename = "width")]
		width: width::Type,
		#[serde(rename = "height")]
		height: height::Type,
		#[serde(rename = "aspect_ratio_num")]
		aspect_ratio_num: aspect_ratio_num::Type,
		#[serde(rename = "aspect_ratio_Den")]
		aspect_ratio_den: aspect_ratio_den::Type,
		#[serde(rename = "properties")]
		properties: properties::Type,
		#[serde(rename = "codec")]
		codec: codec::Type,
		#[serde(rename = "codec_id")]
		codec_id: codec_id::Type,
	},
	[
		(id, Scalar),
		(pixel_format, Scalar),
		(color_range, Scalar),
		(bits_per_channel, Scalar),
		(color_space, Scalar),
		(color_primaries, Scalar),
		(color_transfer, Scalar),
		(field_order, Scalar),
		(chroma_location, Scalar),
		(width, Scalar),
		(height, Scalar),
		(aspect_ratio_num, Scalar),
		(aspect_ratio_den, Scalar),
		(properties, Scalar),
		(codec, Relation(prisma::ffmpeg_media_codec, One)),
		(codec_id, Scalar)
	]
);
pub enum SelectParam {
	Id(id::Select),
	PixelFormat(pixel_format::Select),
	ColorRange(color_range::Select),
	BitsPerChannel(bits_per_channel::Select),
	ColorSpace(color_space::Select),
	ColorPrimaries(color_primaries::Select),
	ColorTransfer(color_transfer::Select),
	FieldOrder(field_order::Select),
	ChromaLocation(chroma_location::Select),
	Width(width::Select),
	Height(height::Select),
	AspectRatioNum(aspect_ratio_num::Select),
	AspectRatioDen(aspect_ratio_den::Select),
	Properties(properties::Select),
	Codec(codec::Select),
	CodecId(codec_id::Select),
}
impl Into<::prisma_client_rust::Selection> for SelectParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::PixelFormat(data) => data.into(),
			Self::ColorRange(data) => data.into(),
			Self::BitsPerChannel(data) => data.into(),
			Self::ColorSpace(data) => data.into(),
			Self::ColorPrimaries(data) => data.into(),
			Self::ColorTransfer(data) => data.into(),
			Self::FieldOrder(data) => data.into(),
			Self::ChromaLocation(data) => data.into(),
			Self::Width(data) => data.into(),
			Self::Height(data) => data.into(),
			Self::AspectRatioNum(data) => data.into(),
			Self::AspectRatioDen(data) => data.into(),
			Self::Properties(data) => data.into(),
			Self::Codec(data) => data.into(),
			Self::CodecId(data) => data.into(),
		}
	}
}
::prisma_client_rust::macros::include_factory!(
	_include_ffmpeg_media_video_props,
	include,
	prisma::ffmpeg_media_video_props,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "pixel_format")]
		pixel_format: pixel_format::Type,
		#[serde(rename = "color_range")]
		color_range: color_range::Type,
		#[serde(rename = "bits_per_channel")]
		bits_per_channel: bits_per_channel::Type,
		#[serde(rename = "color_space")]
		color_space: color_space::Type,
		#[serde(rename = "color_primaries")]
		color_primaries: color_primaries::Type,
		#[serde(rename = "color_transfer")]
		color_transfer: color_transfer::Type,
		#[serde(rename = "field_order")]
		field_order: field_order::Type,
		#[serde(rename = "chroma_location")]
		chroma_location: chroma_location::Type,
		#[serde(rename = "width")]
		width: width::Type,
		#[serde(rename = "height")]
		height: height::Type,
		#[serde(rename = "aspect_ratio_num")]
		aspect_ratio_num: aspect_ratio_num::Type,
		#[serde(rename = "aspect_ratio_Den")]
		aspect_ratio_den: aspect_ratio_den::Type,
		#[serde(rename = "properties")]
		properties: properties::Type,
		#[serde(rename = "codec")]
		codec: codec::Type,
		#[serde(rename = "codec_id")]
		codec_id: codec_id::Type,
	},
	[(codec, Relation(prisma::ffmpeg_media_codec, One))]
);
pub enum IncludeParam {
	Id(id::Include),
	PixelFormat(pixel_format::Include),
	ColorRange(color_range::Include),
	BitsPerChannel(bits_per_channel::Include),
	ColorSpace(color_space::Include),
	ColorPrimaries(color_primaries::Include),
	ColorTransfer(color_transfer::Include),
	FieldOrder(field_order::Include),
	ChromaLocation(chroma_location::Include),
	Width(width::Include),
	Height(height::Include),
	AspectRatioNum(aspect_ratio_num::Include),
	AspectRatioDen(aspect_ratio_den::Include),
	Properties(properties::Include),
	Codec(codec::Include),
	CodecId(codec_id::Include),
}
impl Into<::prisma_client_rust::Selection> for IncludeParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::PixelFormat(data) => data.into(),
			Self::ColorRange(data) => data.into(),
			Self::BitsPerChannel(data) => data.into(),
			Self::ColorSpace(data) => data.into(),
			Self::ColorPrimaries(data) => data.into(),
			Self::ColorTransfer(data) => data.into(),
			Self::FieldOrder(data) => data.into(),
			Self::ChromaLocation(data) => data.into(),
			Self::Width(data) => data.into(),
			Self::Height(data) => data.into(),
			Self::AspectRatioNum(data) => data.into(),
			Self::AspectRatioDen(data) => data.into(),
			Self::Properties(data) => data.into(),
			Self::Codec(data) => data.into(),
			Self::CodecId(data) => data.into(),
		}
	}
}
#[derive(Debug, Clone)]
pub struct Create {
	pub width: Int,
	pub height: Int,
	pub codec: super::ffmpeg_media_codec::UniqueWhereParam,
	pub _params: Vec<SetParam>,
}
impl Create {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
		client
			.ffmpeg_media_video_props()
			.create(self.width, self.height, self.codec, self._params)
	}
	pub fn to_params(mut self) -> Vec<SetParam> {
		self._params.extend([
			width::set(self.width),
			height::set(self.height),
			codec::connect(self.codec),
		]);
		self._params
	}
}
pub fn create(
	width: Int,
	height: Int,
	codec: super::ffmpeg_media_codec::UniqueWhereParam,
	_params: Vec<SetParam>,
) -> Create {
	Create {
		width,
		height,
		codec,
		_params,
	}
}
#[derive(Debug, Clone)]
pub struct CreateUnchecked {
	pub width: Int,
	pub height: Int,
	pub codec_id: Int,
	pub _params: Vec<UncheckedSetParam>,
}
impl CreateUnchecked {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
		client.ffmpeg_media_video_props().create_unchecked(
			self.width,
			self.height,
			self.codec_id,
			self._params,
		)
	}
	pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
		self._params.extend([
			width::set(self.width),
			height::set(self.height),
			codec_id::set(self.codec_id),
		]);
		self._params
	}
}
pub fn create_unchecked(
	width: Int,
	height: Int,
	codec_id: Int,
	_params: Vec<UncheckedSetParam>,
) -> CreateUnchecked {
	CreateUnchecked {
		width,
		height,
		codec_id,
		_params,
	}
}
#[derive(Debug, Clone)]
pub struct Types;
impl ::prisma_client_rust::ModelTypes for Types {
	type Data = Data;
	type Where = WhereParam;
	type WhereUnique = UniqueWhereParam;
	type UncheckedSet = UncheckedSetParam;
	type Set = SetParam;
	type With = WithParam;
	type OrderBy = OrderByWithRelationParam;
	type Cursor = UniqueWhereParam;
	const MODEL: &'static str = NAME;
	fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
		vec![
			::prisma_client_rust::sel(id::NAME),
			::prisma_client_rust::sel(pixel_format::NAME),
			::prisma_client_rust::sel(color_range::NAME),
			::prisma_client_rust::sel(bits_per_channel::NAME),
			::prisma_client_rust::sel(color_space::NAME),
			::prisma_client_rust::sel(color_primaries::NAME),
			::prisma_client_rust::sel(color_transfer::NAME),
			::prisma_client_rust::sel(field_order::NAME),
			::prisma_client_rust::sel(chroma_location::NAME),
			::prisma_client_rust::sel(width::NAME),
			::prisma_client_rust::sel(height::NAME),
			::prisma_client_rust::sel(aspect_ratio_num::NAME),
			::prisma_client_rust::sel(aspect_ratio_den::NAME),
			::prisma_client_rust::sel(properties::NAME),
			::prisma_client_rust::sel(codec_id::NAME),
		]
	}
}
#[derive(
	Debug,
	Clone,
	:: serde :: Serialize,
	:: serde :: Deserialize,
	:: prisma_client_rust :: specta :: Type,
)]
# [specta (rename = "FfmpegMediaVideoProps" , crate = prisma_client_rust :: specta)]
pub struct Data {
	#[serde(rename = "id")]
	pub id: id::Type,
	#[serde(rename = "pixel_format")]
	pub pixel_format: pixel_format::Type,
	#[serde(rename = "color_range")]
	pub color_range: color_range::Type,
	#[serde(rename = "bits_per_channel")]
	pub bits_per_channel: bits_per_channel::Type,
	#[serde(rename = "color_space")]
	pub color_space: color_space::Type,
	#[serde(rename = "color_primaries")]
	pub color_primaries: color_primaries::Type,
	#[serde(rename = "color_transfer")]
	pub color_transfer: color_transfer::Type,
	#[serde(rename = "field_order")]
	pub field_order: field_order::Type,
	#[serde(rename = "chroma_location")]
	pub chroma_location: chroma_location::Type,
	#[serde(rename = "width")]
	pub width: width::Type,
	#[serde(rename = "height")]
	pub height: height::Type,
	#[serde(rename = "aspect_ratio_num")]
	pub aspect_ratio_num: aspect_ratio_num::Type,
	#[serde(rename = "aspect_ratio_Den")]
	pub aspect_ratio_den: aspect_ratio_den::Type,
	#[serde(rename = "properties")]
	pub properties: properties::Type,
	#[serde(rename = "codec")]
	#[specta(skip)]
	pub codec: Option<codec::RecursiveSafeType>,
	#[serde(rename = "codec_id")]
	pub codec_id: codec_id::Type,
}
impl Data {
	pub fn codec(
		&self,
	) -> Result<&super::ffmpeg_media_codec::Data, ::prisma_client_rust::RelationNotFetchedError> {
		self.codec
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(codec),
			))
			.map(|v| v.as_ref())
	}
}
::prisma_client_rust::macros::partial_unchecked_factory!(
	_partial_unchecked_ffmpeg_media_video_props,
	prisma::ffmpeg_media_video_props,
	struct Data {
		#[serde(rename = "id")]
		pub id: prisma::ffmpeg_media_video_props::id::Type,
		#[serde(rename = "pixel_format")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub pixel_format: prisma::ffmpeg_media_video_props::pixel_format::Type,
		#[serde(rename = "color_range")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub color_range: prisma::ffmpeg_media_video_props::color_range::Type,
		#[serde(rename = "bits_per_channel")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub bits_per_channel: prisma::ffmpeg_media_video_props::bits_per_channel::Type,
		#[serde(rename = "color_space")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub color_space: prisma::ffmpeg_media_video_props::color_space::Type,
		#[serde(rename = "color_primaries")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub color_primaries: prisma::ffmpeg_media_video_props::color_primaries::Type,
		#[serde(rename = "color_transfer")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub color_transfer: prisma::ffmpeg_media_video_props::color_transfer::Type,
		#[serde(rename = "field_order")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub field_order: prisma::ffmpeg_media_video_props::field_order::Type,
		#[serde(rename = "chroma_location")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub chroma_location: prisma::ffmpeg_media_video_props::chroma_location::Type,
		#[serde(rename = "width")]
		pub width: prisma::ffmpeg_media_video_props::width::Type,
		#[serde(rename = "height")]
		pub height: prisma::ffmpeg_media_video_props::height::Type,
		#[serde(rename = "aspect_ratio_num")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub aspect_ratio_num: prisma::ffmpeg_media_video_props::aspect_ratio_num::Type,
		#[serde(rename = "aspect_ratio_Den")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub aspect_ratio_den: prisma::ffmpeg_media_video_props::aspect_ratio_den::Type,
		#[serde(rename = "properties")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub properties: prisma::ffmpeg_media_video_props::properties::Type,
		#[serde(rename = "codec_id")]
		pub codec_id: prisma::ffmpeg_media_video_props::codec_id::Type,
	}
);
::prisma_client_rust::macros::filter_factory!(
	_ffmpeg_media_video_props_filter,
	prisma::ffmpeg_media_video_props,
	[
		(id, Scalar),
		(pixel_format, Scalar),
		(color_range, Scalar),
		(bits_per_channel, Scalar),
		(color_space, Scalar),
		(color_primaries, Scalar),
		(color_transfer, Scalar),
		(field_order, Scalar),
		(chroma_location, Scalar),
		(width, Scalar),
		(height, Scalar),
		(aspect_ratio_num, Scalar),
		(aspect_ratio_den, Scalar),
		(properties, Scalar),
		(codec, Relation(prisma::ffmpeg_media_codec, One)),
		(codec_id, Scalar)
	]
);
pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
#[derive(Clone)]
pub struct Actions<'a> {
	pub client: &'a ::prisma_client_rust::PrismaClientInternals,
}
impl<'a> Actions<'a> {
	pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
		FindUniqueQuery::new(self.client, _where)
	}
	pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
		FindFirstQuery::new(self.client, _where)
	}
	pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
		FindManyQuery::new(self.client, _where)
	}
	pub fn create(
		self,
		width: Int,
		height: Int,
		codec: super::ffmpeg_media_codec::UniqueWhereParam,
		mut _params: Vec<SetParam>,
	) -> CreateQuery<'a> {
		_params.extend([
			width::set(width),
			height::set(height),
			codec::connect(codec),
		]);
		CreateQuery::new(self.client, _params)
	}
	pub fn create_unchecked(
		self,
		width: Int,
		height: Int,
		codec_id: Int,
		mut _params: Vec<UncheckedSetParam>,
	) -> CreateUncheckedQuery<'a> {
		_params.extend([
			width::set(width),
			height::set(height),
			codec_id::set(codec_id),
		]);
		CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
	}
	pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
		let data = data.into_iter().map(CreateUnchecked::to_params).collect();
		CreateManyQuery::new(self.client, data)
	}
	pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
		UpdateQuery::new(self.client, _where, _params, vec![])
	}
	pub fn update_unchecked(
		self,
		_where: UniqueWhereParam,
		_params: Vec<UncheckedSetParam>,
	) -> UpdateUncheckedQuery<'a> {
		UpdateUncheckedQuery::new(
			self.client,
			_where,
			_params.into_iter().map(Into::into).collect(),
			vec![],
		)
	}
	pub fn update_many(
		self,
		_where: Vec<WhereParam>,
		_params: Vec<SetParam>,
	) -> UpdateManyQuery<'a> {
		UpdateManyQuery::new(self.client, _where, _params)
	}
	pub fn upsert(
		self,
		_where: UniqueWhereParam,
		_create: Create,
		_update: Vec<SetParam>,
	) -> UpsertQuery<'a> {
		UpsertQuery::new(self.client, _where, _create.to_params(), _update)
	}
	pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
		DeleteQuery::new(self.client, _where, vec![])
	}
	pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
		DeleteManyQuery::new(self.client, _where)
	}
	pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
		CountQuery::new(self.client, _where)
	}
}
