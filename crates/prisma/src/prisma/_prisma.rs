// File generated by Prisma Client Rust. DO NOT EDIT

use super::*;
pub struct PrismaClientBuilder {
	url: Option<String>,
	action_notifier: ::prisma_client_rust::ActionNotifier,
}
impl PrismaClientBuilder {
	fn new() -> Self {
		Self {
			url: None,
			action_notifier: ::prisma_client_rust::ActionNotifier::new(),
		}
	}
	pub fn with_url(mut self, url: String) -> Self {
		self.url = Some(url);
		self
	}
	pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
		let internals = ::prisma_client_rust::PrismaClientInternals::new(
			self.url,
			self.action_notifier,
			super::DATAMODEL_STR,
		)
		.await?;
		Ok(PrismaClient(internals))
	}
}
pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
impl ::std::fmt::Debug for PrismaClient {
	fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
		f.debug_struct("PrismaClient").finish()
	}
}
impl PrismaClient {
	pub fn _builder() -> PrismaClientBuilder {
		PrismaClientBuilder::new()
	}
	pub fn _query_raw<T: ::prisma_client_rust::Data>(
		&self,
		query: ::prisma_client_rust::Raw,
	) -> ::prisma_client_rust::QueryRaw<T> {
		::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
	}
	pub fn _execute_raw(
		&self,
		query: ::prisma_client_rust::Raw,
	) -> ::prisma_client_rust::ExecuteRaw {
		::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
	}
	pub async fn _batch<'batch, T: ::prisma_client_rust::BatchContainer<'batch, Marker>, Marker>(
		&self,
		queries: T,
	) -> ::prisma_client_rust::Result<
		<T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
	> {
		::prisma_client_rust::batch(queries, &self.0).await
	}
	pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
		::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
	}
	pub async fn _migrate_deploy(
		&self,
	) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
		let res = ::prisma_client_rust::migrations::migrate_deploy(
			super::DATAMODEL_STR,
			super::MIGRATIONS_DIR,
			&self.0.url(),
		)
		.await;
		::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
		res
	}
	pub async fn _migrate_resolve(
		&self,
		migration: &str,
	) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
		::prisma_client_rust::migrations::migrate_resolve(
			migration,
			super::DATAMODEL_STR,
			super::MIGRATIONS_DIR,
			&self.0.url(),
		)
		.await
	}
	pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
		::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url())
	}
	pub fn crdt_operation(&self) -> super::crdt_operation::Actions {
		super::crdt_operation::Actions { client: &self.0 }
	}
	pub fn cloud_crdt_operation(&self) -> super::cloud_crdt_operation::Actions {
		super::cloud_crdt_operation::Actions { client: &self.0 }
	}
	pub fn node(&self) -> super::node::Actions {
		super::node::Actions { client: &self.0 }
	}
	pub fn instance(&self) -> super::instance::Actions {
		super::instance::Actions { client: &self.0 }
	}
	pub fn statistics(&self) -> super::statistics::Actions {
		super::statistics::Actions { client: &self.0 }
	}
	pub fn volume(&self) -> super::volume::Actions {
		super::volume::Actions { client: &self.0 }
	}
	pub fn location(&self) -> super::location::Actions {
		super::location::Actions { client: &self.0 }
	}
	pub fn file_path(&self) -> super::file_path::Actions {
		super::file_path::Actions { client: &self.0 }
	}
	pub fn object(&self) -> super::object::Actions {
		super::object::Actions { client: &self.0 }
	}
	pub fn exif_data(&self) -> super::exif_data::Actions {
		super::exif_data::Actions { client: &self.0 }
	}
	pub fn ffmpeg_data(&self) -> super::ffmpeg_data::Actions {
		super::ffmpeg_data::Actions { client: &self.0 }
	}
	pub fn ffmpeg_media_chapter(&self) -> super::ffmpeg_media_chapter::Actions {
		super::ffmpeg_media_chapter::Actions { client: &self.0 }
	}
	pub fn ffmpeg_media_program(&self) -> super::ffmpeg_media_program::Actions {
		super::ffmpeg_media_program::Actions { client: &self.0 }
	}
	pub fn ffmpeg_media_stream(&self) -> super::ffmpeg_media_stream::Actions {
		super::ffmpeg_media_stream::Actions { client: &self.0 }
	}
	pub fn ffmpeg_media_codec(&self) -> super::ffmpeg_media_codec::Actions {
		super::ffmpeg_media_codec::Actions { client: &self.0 }
	}
	pub fn ffmpeg_media_video_props(&self) -> super::ffmpeg_media_video_props::Actions {
		super::ffmpeg_media_video_props::Actions { client: &self.0 }
	}
	pub fn ffmpeg_media_audio_props(&self) -> super::ffmpeg_media_audio_props::Actions {
		super::ffmpeg_media_audio_props::Actions { client: &self.0 }
	}
	pub fn tag(&self) -> super::tag::Actions {
		super::tag::Actions { client: &self.0 }
	}
	pub fn tag_on_object(&self) -> super::tag_on_object::Actions {
		super::tag_on_object::Actions { client: &self.0 }
	}
	pub fn label(&self) -> super::label::Actions {
		super::label::Actions { client: &self.0 }
	}
	pub fn label_on_object(&self) -> super::label_on_object::Actions {
		super::label_on_object::Actions { client: &self.0 }
	}
	pub fn space(&self) -> super::space::Actions {
		super::space::Actions { client: &self.0 }
	}
	pub fn object_in_space(&self) -> super::object_in_space::Actions {
		super::object_in_space::Actions { client: &self.0 }
	}
	pub fn job(&self) -> super::job::Actions {
		super::job::Actions { client: &self.0 }
	}
	pub fn album(&self) -> super::album::Actions {
		super::album::Actions { client: &self.0 }
	}
	pub fn object_in_album(&self) -> super::object_in_album::Actions {
		super::object_in_album::Actions { client: &self.0 }
	}
	pub fn indexer_rule(&self) -> super::indexer_rule::Actions {
		super::indexer_rule::Actions { client: &self.0 }
	}
	pub fn indexer_rules_in_location(&self) -> super::indexer_rules_in_location::Actions {
		super::indexer_rules_in_location::Actions { client: &self.0 }
	}
	pub fn preference(&self) -> super::preference::Actions {
		super::preference::Actions { client: &self.0 }
	}
	pub fn notification(&self) -> super::notification::Actions {
		super::notification::Actions { client: &self.0 }
	}
	pub fn saved_search(&self) -> super::saved_search::Actions {
		super::saved_search::Actions { client: &self.0 }
	}
}
impl ::prisma_client_rust::PrismaClient for PrismaClient {
	fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
		&self.0
	}
	fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
		&mut self.0
	}
	fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
		Self(self.0.with_tx_id(tx_id))
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum TransactionIsolationLevel {
	#[serde(rename = "Serializable")]
	Serializable,
}
impl ToString for TransactionIsolationLevel {
	fn to_string(&self) -> String {
		match self {
			Self::Serializable => "Serializable".to_string(),
		}
	}
}
impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum CrdtOperationScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "timestamp")]
	Timestamp,
	#[serde(rename = "model")]
	Model,
	#[serde(rename = "record_id")]
	RecordId,
	#[serde(rename = "kind")]
	Kind,
	#[serde(rename = "data")]
	Data,
	#[serde(rename = "instance_id")]
	InstanceId,
}
impl ToString for CrdtOperationScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Timestamp => "timestamp".to_string(),
			Self::Model => "model".to_string(),
			Self::RecordId => "record_id".to_string(),
			Self::Kind => "kind".to_string(),
			Self::Data => "data".to_string(),
			Self::InstanceId => "instance_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum CloudCrdtOperationScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "timestamp")]
	Timestamp,
	#[serde(rename = "model")]
	Model,
	#[serde(rename = "record_id")]
	RecordId,
	#[serde(rename = "kind")]
	Kind,
	#[serde(rename = "data")]
	Data,
	#[serde(rename = "instance_id")]
	InstanceId,
}
impl ToString for CloudCrdtOperationScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Timestamp => "timestamp".to_string(),
			Self::Model => "model".to_string(),
			Self::RecordId => "record_id".to_string(),
			Self::Kind => "kind".to_string(),
			Self::Data => "data".to_string(),
			Self::InstanceId => "instance_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum NodeScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "platform")]
	Platform,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "identity")]
	Identity,
}
impl ToString for NodeScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Name => "name".to_string(),
			Self::Platform => "platform".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::Identity => "identity".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum InstanceScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "identity")]
	Identity,
	#[serde(rename = "remote_identity")]
	RemoteIdentity,
	#[serde(rename = "node_id")]
	NodeId,
	#[serde(rename = "node_remote_identity")]
	NodeRemoteIdentity,
	#[serde(rename = "metadata")]
	Metadata,
	#[serde(rename = "last_seen")]
	LastSeen,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "timestamp")]
	Timestamp,
}
impl ToString for InstanceScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Identity => "identity".to_string(),
			Self::RemoteIdentity => "remote_identity".to_string(),
			Self::NodeId => "node_id".to_string(),
			Self::NodeRemoteIdentity => "node_remote_identity".to_string(),
			Self::Metadata => "metadata".to_string(),
			Self::LastSeen => "last_seen".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::Timestamp => "timestamp".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum StatisticsScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "date_captured")]
	DateCaptured,
	#[serde(rename = "total_object_count")]
	TotalObjectCount,
	#[serde(rename = "library_db_size")]
	LibraryDbSize,
	#[serde(rename = "total_local_bytes_used")]
	TotalLocalBytesUsed,
	#[serde(rename = "total_local_bytes_capacity")]
	TotalLocalBytesCapacity,
	#[serde(rename = "total_local_bytes_free")]
	TotalLocalBytesFree,
	#[serde(rename = "total_library_bytes")]
	TotalLibraryBytes,
	#[serde(rename = "total_library_unique_bytes")]
	TotalLibraryUniqueBytes,
	#[serde(rename = "total_library_preview_media_bytes")]
	TotalLibraryPreviewMediaBytes,
}
impl ToString for StatisticsScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::DateCaptured => "date_captured".to_string(),
			Self::TotalObjectCount => "total_object_count".to_string(),
			Self::LibraryDbSize => "library_db_size".to_string(),
			Self::TotalLocalBytesUsed => "total_local_bytes_used".to_string(),
			Self::TotalLocalBytesCapacity => "total_local_bytes_capacity".to_string(),
			Self::TotalLocalBytesFree => "total_local_bytes_free".to_string(),
			Self::TotalLibraryBytes => "total_library_bytes".to_string(),
			Self::TotalLibraryUniqueBytes => "total_library_unique_bytes".to_string(),
			Self::TotalLibraryPreviewMediaBytes => "total_library_preview_media_bytes".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum VolumeScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "mount_point")]
	MountPoint,
	#[serde(rename = "total_bytes_capacity")]
	TotalBytesCapacity,
	#[serde(rename = "total_bytes_available")]
	TotalBytesAvailable,
	#[serde(rename = "disk_type")]
	DiskType,
	#[serde(rename = "filesystem")]
	Filesystem,
	#[serde(rename = "is_system")]
	IsSystem,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for VolumeScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Name => "name".to_string(),
			Self::MountPoint => "mount_point".to_string(),
			Self::TotalBytesCapacity => "total_bytes_capacity".to_string(),
			Self::TotalBytesAvailable => "total_bytes_available".to_string(),
			Self::DiskType => "disk_type".to_string(),
			Self::Filesystem => "filesystem".to_string(),
			Self::IsSystem => "is_system".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum LocationScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "path")]
	Path,
	#[serde(rename = "total_capacity")]
	TotalCapacity,
	#[serde(rename = "available_capacity")]
	AvailableCapacity,
	#[serde(rename = "size_in_bytes")]
	SizeInBytes,
	#[serde(rename = "is_archived")]
	IsArchived,
	#[serde(rename = "generate_preview_media")]
	GeneratePreviewMedia,
	#[serde(rename = "sync_preview_media")]
	SyncPreviewMedia,
	#[serde(rename = "hidden")]
	Hidden,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "scan_state")]
	ScanState,
	#[serde(rename = "instance_id")]
	InstanceId,
}
impl ToString for LocationScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Name => "name".to_string(),
			Self::Path => "path".to_string(),
			Self::TotalCapacity => "total_capacity".to_string(),
			Self::AvailableCapacity => "available_capacity".to_string(),
			Self::SizeInBytes => "size_in_bytes".to_string(),
			Self::IsArchived => "is_archived".to_string(),
			Self::GeneratePreviewMedia => "generate_preview_media".to_string(),
			Self::SyncPreviewMedia => "sync_preview_media".to_string(),
			Self::Hidden => "hidden".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::ScanState => "scan_state".to_string(),
			Self::InstanceId => "instance_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FilePathScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "is_dir")]
	IsDir,
	#[serde(rename = "cas_id")]
	CasId,
	#[serde(rename = "integrity_checksum")]
	IntegrityChecksum,
	#[serde(rename = "location_id")]
	LocationId,
	#[serde(rename = "materialized_path")]
	MaterializedPath,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "extension")]
	Extension,
	#[serde(rename = "hidden")]
	Hidden,
	#[serde(rename = "size_in_bytes")]
	SizeInBytes,
	#[serde(rename = "size_in_bytes_bytes")]
	SizeInBytesBytes,
	#[serde(rename = "inode")]
	Inode,
	#[serde(rename = "object_id")]
	ObjectId,
	#[serde(rename = "key_id")]
	KeyId,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
	#[serde(rename = "date_indexed")]
	DateIndexed,
}
impl ToString for FilePathScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::IsDir => "is_dir".to_string(),
			Self::CasId => "cas_id".to_string(),
			Self::IntegrityChecksum => "integrity_checksum".to_string(),
			Self::LocationId => "location_id".to_string(),
			Self::MaterializedPath => "materialized_path".to_string(),
			Self::Name => "name".to_string(),
			Self::Extension => "extension".to_string(),
			Self::Hidden => "hidden".to_string(),
			Self::SizeInBytes => "size_in_bytes".to_string(),
			Self::SizeInBytesBytes => "size_in_bytes_bytes".to_string(),
			Self::Inode => "inode".to_string(),
			Self::ObjectId => "object_id".to_string(),
			Self::KeyId => "key_id".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
			Self::DateIndexed => "date_indexed".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ObjectScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "kind")]
	Kind,
	#[serde(rename = "key_id")]
	KeyId,
	#[serde(rename = "hidden")]
	Hidden,
	#[serde(rename = "favorite")]
	Favorite,
	#[serde(rename = "important")]
	Important,
	#[serde(rename = "note")]
	Note,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_accessed")]
	DateAccessed,
}
impl ToString for ObjectScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Kind => "kind".to_string(),
			Self::KeyId => "key_id".to_string(),
			Self::Hidden => "hidden".to_string(),
			Self::Favorite => "favorite".to_string(),
			Self::Important => "important".to_string(),
			Self::Note => "note".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateAccessed => "date_accessed".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ExifDataScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "resolution")]
	Resolution,
	#[serde(rename = "media_date")]
	MediaDate,
	#[serde(rename = "media_location")]
	MediaLocation,
	#[serde(rename = "camera_data")]
	CameraData,
	#[serde(rename = "artist")]
	Artist,
	#[serde(rename = "description")]
	Description,
	#[serde(rename = "copyright")]
	Copyright,
	#[serde(rename = "exif_version")]
	ExifVersion,
	#[serde(rename = "epoch_time")]
	EpochTime,
	#[serde(rename = "object_id")]
	ObjectId,
}
impl ToString for ExifDataScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Resolution => "resolution".to_string(),
			Self::MediaDate => "media_date".to_string(),
			Self::MediaLocation => "media_location".to_string(),
			Self::CameraData => "camera_data".to_string(),
			Self::Artist => "artist".to_string(),
			Self::Description => "description".to_string(),
			Self::Copyright => "copyright".to_string(),
			Self::ExifVersion => "exif_version".to_string(),
			Self::EpochTime => "epoch_time".to_string(),
			Self::ObjectId => "object_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegDataScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "formats")]
	Formats,
	#[serde(rename = "bit_rate")]
	BitRate,
	#[serde(rename = "duration")]
	Duration,
	#[serde(rename = "start_time")]
	StartTime,
	#[serde(rename = "title")]
	Title,
	#[serde(rename = "creation_time")]
	CreationTime,
	#[serde(rename = "date")]
	Date,
	#[serde(rename = "album_artist")]
	AlbumArtist,
	#[serde(rename = "disc")]
	Disc,
	#[serde(rename = "track")]
	Track,
	#[serde(rename = "album")]
	Album,
	#[serde(rename = "artist")]
	Artist,
	#[serde(rename = "metadata")]
	Metadata,
	#[serde(rename = "object_id")]
	ObjectId,
}
impl ToString for FfmpegDataScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Formats => "formats".to_string(),
			Self::BitRate => "bit_rate".to_string(),
			Self::Duration => "duration".to_string(),
			Self::StartTime => "start_time".to_string(),
			Self::Title => "title".to_string(),
			Self::CreationTime => "creation_time".to_string(),
			Self::Date => "date".to_string(),
			Self::AlbumArtist => "album_artist".to_string(),
			Self::Disc => "disc".to_string(),
			Self::Track => "track".to_string(),
			Self::Album => "album".to_string(),
			Self::Artist => "artist".to_string(),
			Self::Metadata => "metadata".to_string(),
			Self::ObjectId => "object_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegMediaChapterScalarFieldEnum {
	#[serde(rename = "chapter_id")]
	ChapterId,
	#[serde(rename = "start")]
	Start,
	#[serde(rename = "end")]
	End,
	#[serde(rename = "time_base_den")]
	TimeBaseDen,
	#[serde(rename = "time_base_num")]
	TimeBaseNum,
	#[serde(rename = "title")]
	Title,
	#[serde(rename = "metadata")]
	Metadata,
	#[serde(rename = "ffmpeg_data_id")]
	FfmpegDataId,
}
impl ToString for FfmpegMediaChapterScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::ChapterId => "chapter_id".to_string(),
			Self::Start => "start".to_string(),
			Self::End => "end".to_string(),
			Self::TimeBaseDen => "time_base_den".to_string(),
			Self::TimeBaseNum => "time_base_num".to_string(),
			Self::Title => "title".to_string(),
			Self::Metadata => "metadata".to_string(),
			Self::FfmpegDataId => "ffmpeg_data_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegMediaProgramScalarFieldEnum {
	#[serde(rename = "program_id")]
	ProgramId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "metadata")]
	Metadata,
	#[serde(rename = "ffmpeg_data_id")]
	FfmpegDataId,
}
impl ToString for FfmpegMediaProgramScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::ProgramId => "program_id".to_string(),
			Self::Name => "name".to_string(),
			Self::Metadata => "metadata".to_string(),
			Self::FfmpegDataId => "ffmpeg_data_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegMediaStreamScalarFieldEnum {
	#[serde(rename = "stream_id")]
	StreamId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "aspect_ratio_num")]
	AspectRatioNum,
	#[serde(rename = "aspect_ratio_den")]
	AspectRatioDen,
	#[serde(rename = "frames_per_second_num")]
	FramesPerSecondNum,
	#[serde(rename = "frames_per_second_den")]
	FramesPerSecondDen,
	#[serde(rename = "time_base_real_den")]
	TimeBaseRealDen,
	#[serde(rename = "time_base_real_num")]
	TimeBaseRealNum,
	#[serde(rename = "dispositions")]
	Dispositions,
	#[serde(rename = "title")]
	Title,
	#[serde(rename = "encoder")]
	Encoder,
	#[serde(rename = "language")]
	Language,
	#[serde(rename = "duration")]
	Duration,
	#[serde(rename = "metadata")]
	Metadata,
	#[serde(rename = "program_id")]
	ProgramId,
	#[serde(rename = "ffmpeg_data_id")]
	FfmpegDataId,
}
impl ToString for FfmpegMediaStreamScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::StreamId => "stream_id".to_string(),
			Self::Name => "name".to_string(),
			Self::AspectRatioNum => "aspect_ratio_num".to_string(),
			Self::AspectRatioDen => "aspect_ratio_den".to_string(),
			Self::FramesPerSecondNum => "frames_per_second_num".to_string(),
			Self::FramesPerSecondDen => "frames_per_second_den".to_string(),
			Self::TimeBaseRealDen => "time_base_real_den".to_string(),
			Self::TimeBaseRealNum => "time_base_real_num".to_string(),
			Self::Dispositions => "dispositions".to_string(),
			Self::Title => "title".to_string(),
			Self::Encoder => "encoder".to_string(),
			Self::Language => "language".to_string(),
			Self::Duration => "duration".to_string(),
			Self::Metadata => "metadata".to_string(),
			Self::ProgramId => "program_id".to_string(),
			Self::FfmpegDataId => "ffmpeg_data_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegMediaCodecScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "kind")]
	Kind,
	#[serde(rename = "sub_kind")]
	SubKind,
	#[serde(rename = "tag")]
	Tag,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "profile")]
	Profile,
	#[serde(rename = "bit_rate")]
	BitRate,
	#[serde(rename = "stream_id")]
	StreamId,
	#[serde(rename = "program_id")]
	ProgramId,
	#[serde(rename = "ffmpeg_data_id")]
	FfmpegDataId,
}
impl ToString for FfmpegMediaCodecScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Kind => "kind".to_string(),
			Self::SubKind => "sub_kind".to_string(),
			Self::Tag => "tag".to_string(),
			Self::Name => "name".to_string(),
			Self::Profile => "profile".to_string(),
			Self::BitRate => "bit_rate".to_string(),
			Self::StreamId => "stream_id".to_string(),
			Self::ProgramId => "program_id".to_string(),
			Self::FfmpegDataId => "ffmpeg_data_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegMediaVideoPropsScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pixel_format")]
	PixelFormat,
	#[serde(rename = "color_range")]
	ColorRange,
	#[serde(rename = "bits_per_channel")]
	BitsPerChannel,
	#[serde(rename = "color_space")]
	ColorSpace,
	#[serde(rename = "color_primaries")]
	ColorPrimaries,
	#[serde(rename = "color_transfer")]
	ColorTransfer,
	#[serde(rename = "field_order")]
	FieldOrder,
	#[serde(rename = "chroma_location")]
	ChromaLocation,
	#[serde(rename = "width")]
	Width,
	#[serde(rename = "height")]
	Height,
	#[serde(rename = "aspect_ratio_num")]
	AspectRatioNum,
	#[serde(rename = "aspect_ratio_Den")]
	AspectRatioDen,
	#[serde(rename = "properties")]
	Properties,
	#[serde(rename = "codec_id")]
	CodecId,
}
impl ToString for FfmpegMediaVideoPropsScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PixelFormat => "pixel_format".to_string(),
			Self::ColorRange => "color_range".to_string(),
			Self::BitsPerChannel => "bits_per_channel".to_string(),
			Self::ColorSpace => "color_space".to_string(),
			Self::ColorPrimaries => "color_primaries".to_string(),
			Self::ColorTransfer => "color_transfer".to_string(),
			Self::FieldOrder => "field_order".to_string(),
			Self::ChromaLocation => "chroma_location".to_string(),
			Self::Width => "width".to_string(),
			Self::Height => "height".to_string(),
			Self::AspectRatioNum => "aspect_ratio_num".to_string(),
			Self::AspectRatioDen => "aspect_ratio_Den".to_string(),
			Self::Properties => "properties".to_string(),
			Self::CodecId => "codec_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum FfmpegMediaAudioPropsScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "delay")]
	Delay,
	#[serde(rename = "padding")]
	Padding,
	#[serde(rename = "sample_rate")]
	SampleRate,
	#[serde(rename = "sample_format")]
	SampleFormat,
	#[serde(rename = "bit_per_sample")]
	BitPerSample,
	#[serde(rename = "channel_layout")]
	ChannelLayout,
	#[serde(rename = "codec_id")]
	CodecId,
}
impl ToString for FfmpegMediaAudioPropsScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Delay => "delay".to_string(),
			Self::Padding => "padding".to_string(),
			Self::SampleRate => "sample_rate".to_string(),
			Self::SampleFormat => "sample_format".to_string(),
			Self::BitPerSample => "bit_per_sample".to_string(),
			Self::ChannelLayout => "channel_layout".to_string(),
			Self::CodecId => "codec_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum TagScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "color")]
	Color,
	#[serde(rename = "is_hidden")]
	IsHidden,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for TagScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Name => "name".to_string(),
			Self::Color => "color".to_string(),
			Self::IsHidden => "is_hidden".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum TagOnObjectScalarFieldEnum {
	#[serde(rename = "object_id")]
	ObjectId,
	#[serde(rename = "tag_id")]
	TagId,
	#[serde(rename = "date_created")]
	DateCreated,
}
impl ToString for TagOnObjectScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::ObjectId => "object_id".to_string(),
			Self::TagId => "tag_id".to_string(),
			Self::DateCreated => "date_created".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum LabelScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for LabelScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Name => "name".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum LabelOnObjectScalarFieldEnum {
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "object_id")]
	ObjectId,
	#[serde(rename = "label_id")]
	LabelId,
}
impl ToString for LabelOnObjectScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::DateCreated => "date_created".to_string(),
			Self::ObjectId => "object_id".to_string(),
			Self::LabelId => "label_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum SpaceScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "description")]
	Description,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for SpaceScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Name => "name".to_string(),
			Self::Description => "description".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ObjectInSpaceScalarFieldEnum {
	#[serde(rename = "space_id")]
	SpaceId,
	#[serde(rename = "object_id")]
	ObjectId,
}
impl ToString for ObjectInSpaceScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::SpaceId => "space_id".to_string(),
			Self::ObjectId => "object_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum JobScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "action")]
	Action,
	#[serde(rename = "status")]
	Status,
	#[serde(rename = "errors_text")]
	ErrorsText,
	#[serde(rename = "critical_error")]
	CriticalError,
	#[serde(rename = "non_critical_errors")]
	NonCriticalErrors,
	#[serde(rename = "data")]
	Data,
	#[serde(rename = "metadata")]
	Metadata,
	#[serde(rename = "parent_id")]
	ParentId,
	#[serde(rename = "task_count")]
	TaskCount,
	#[serde(rename = "completed_task_count")]
	CompletedTaskCount,
	#[serde(rename = "date_estimated_completion")]
	DateEstimatedCompletion,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_started")]
	DateStarted,
	#[serde(rename = "date_completed")]
	DateCompleted,
}
impl ToString for JobScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Name => "name".to_string(),
			Self::Action => "action".to_string(),
			Self::Status => "status".to_string(),
			Self::ErrorsText => "errors_text".to_string(),
			Self::CriticalError => "critical_error".to_string(),
			Self::NonCriticalErrors => "non_critical_errors".to_string(),
			Self::Data => "data".to_string(),
			Self::Metadata => "metadata".to_string(),
			Self::ParentId => "parent_id".to_string(),
			Self::TaskCount => "task_count".to_string(),
			Self::CompletedTaskCount => "completed_task_count".to_string(),
			Self::DateEstimatedCompletion => "date_estimated_completion".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateStarted => "date_started".to_string(),
			Self::DateCompleted => "date_completed".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum AlbumScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "is_hidden")]
	IsHidden,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for AlbumScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Name => "name".to_string(),
			Self::IsHidden => "is_hidden".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum ObjectInAlbumScalarFieldEnum {
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "album_id")]
	AlbumId,
	#[serde(rename = "object_id")]
	ObjectId,
}
impl ToString for ObjectInAlbumScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::DateCreated => "date_created".to_string(),
			Self::AlbumId => "album_id".to_string(),
			Self::ObjectId => "object_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum IndexerRuleScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "default")]
	Default,
	#[serde(rename = "rules_per_kind")]
	RulesPerKind,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for IndexerRuleScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Name => "name".to_string(),
			Self::Default => "default".to_string(),
			Self::RulesPerKind => "rules_per_kind".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum IndexerRulesInLocationScalarFieldEnum {
	#[serde(rename = "location_id")]
	LocationId,
	#[serde(rename = "indexer_rule_id")]
	IndexerRuleId,
}
impl ToString for IndexerRulesInLocationScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::LocationId => "location_id".to_string(),
			Self::IndexerRuleId => "indexer_rule_id".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum PreferenceScalarFieldEnum {
	#[serde(rename = "key")]
	Key,
	#[serde(rename = "value")]
	Value,
}
impl ToString for PreferenceScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Key => "key".to_string(),
			Self::Value => "value".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum NotificationScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "read")]
	Read,
	#[serde(rename = "data")]
	Data,
	#[serde(rename = "expires_at")]
	ExpiresAt,
}
impl ToString for NotificationScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::Read => "read".to_string(),
			Self::Data => "data".to_string(),
			Self::ExpiresAt => "expires_at".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum SavedSearchScalarFieldEnum {
	#[serde(rename = "id")]
	Id,
	#[serde(rename = "pub_id")]
	PubId,
	#[serde(rename = "target")]
	Target,
	#[serde(rename = "search")]
	Search,
	#[serde(rename = "filters")]
	Filters,
	#[serde(rename = "name")]
	Name,
	#[serde(rename = "icon")]
	Icon,
	#[serde(rename = "description")]
	Description,
	#[serde(rename = "date_created")]
	DateCreated,
	#[serde(rename = "date_modified")]
	DateModified,
}
impl ToString for SavedSearchScalarFieldEnum {
	fn to_string(&self) -> String {
		match self {
			Self::Id => "id".to_string(),
			Self::PubId => "pub_id".to_string(),
			Self::Target => "target".to_string(),
			Self::Search => "search".to_string(),
			Self::Filters => "filters".to_string(),
			Self::Name => "name".to_string(),
			Self::Icon => "icon".to_string(),
			Self::Description => "description".to_string(),
			Self::DateCreated => "date_created".to_string(),
			Self::DateModified => "date_modified".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum SortOrder {
	#[serde(rename = "asc")]
	Asc,
	#[serde(rename = "desc")]
	Desc,
}
impl ToString for SortOrder {
	fn to_string(&self) -> String {
		match self {
			Self::Asc => "asc".to_string(),
			Self::Desc => "desc".to_string(),
		}
	}
}
#[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
pub enum NullsOrder {
	#[serde(rename = "first")]
	First,
	#[serde(rename = "last")]
	Last,
}
impl ToString for NullsOrder {
	fn to_string(&self) -> String {
		match self {
			Self::First => "first".to_string(),
			Self::Last => "last".to_string(),
		}
	}
}
impl Into<::prisma_client_rust::PrismaValue> for SortOrder {
	fn into(self) -> ::prisma_client_rust::PrismaValue {
		match self {
			SortOrder::Asc => ::prisma_client_rust::PrismaValue::String("asc".to_string()),
			SortOrder::Desc => ::prisma_client_rust::PrismaValue::String("desc".to_string()),
		}
	}
}
pub mod read_filters {
	use super::*;
	#[derive(Debug, Clone)]
	pub enum IntFilter {
		Equals(Int),
		InVec(Vec<Int>),
		NotInVec(Vec<Int>),
		Lt(Int),
		Lte(Int),
		Gt(Int),
		Gte(Int),
		Not(Int),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum IntNullableFilter {
		Equals(Option<Int>),
		InVec(Vec<Int>),
		NotInVec(Vec<Int>),
		Lt(Int),
		Lte(Int),
		Gt(Int),
		Gte(Int),
		Not(Option<Int>),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for IntNullableFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BooleanFilter {
		Equals(Boolean),
		Not(Boolean),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BooleanNullableFilter {
		Equals(Option<Boolean>),
		Not(Option<Boolean>),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for BooleanNullableFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BigIntFilter {
		Equals(BigInt),
		InVec(Vec<BigInt>),
		NotInVec(Vec<BigInt>),
		Lt(BigInt),
		Lte(BigInt),
		Gt(BigInt),
		Gte(BigInt),
		Not(BigInt),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BigIntNullableFilter {
		Equals(Option<BigInt>),
		InVec(Vec<BigInt>),
		NotInVec(Vec<BigInt>),
		Lt(BigInt),
		Lte(BigInt),
		Gt(BigInt),
		Gte(BigInt),
		Not(Option<BigInt>),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for BigIntNullableFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BytesFilter {
		Equals(Bytes),
		InVec(Vec<Bytes>),
		NotInVec(Vec<Bytes>),
		Not(Bytes),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for BytesFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					::prisma_client_rust::PrismaValue::Bytes(value),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
								.collect(),
						),
					)])
				}
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					::prisma_client_rust::PrismaValue::Bytes(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BytesNullableFilter {
		Equals(Option<Bytes>),
		InVec(Vec<Bytes>),
		NotInVec(Vec<Bytes>),
		Not(Option<Bytes>),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for BytesNullableFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
								.collect(),
						),
					)])
				}
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum StringFilter {
		Equals(String),
		InVec(Vec<String>),
		NotInVec(Vec<String>),
		Lt(String),
		Lte(String),
		Gt(String),
		Gte(String),
		Contains(String),
		StartsWith(String),
		EndsWith(String),
		Not(String),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::String(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Contains(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)])
				}
				Self::StartsWith(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)])
				}
				Self::EndsWith(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)])
				}
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum StringNullableFilter {
		Equals(Option<String>),
		InVec(Vec<String>),
		NotInVec(Vec<String>),
		Lt(String),
		Lte(String),
		Gt(String),
		Gte(String),
		Contains(String),
		StartsWith(String),
		EndsWith(String),
		Not(Option<String>),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::String(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::String(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::String(value),
				)]),
				Self::Contains(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"contains".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)])
				}
				Self::StartsWith(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"startsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)])
				}
				Self::EndsWith(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"endsWith".to_string(),
						::prisma_client_rust::PrismaValue::String(value),
					)])
				}
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::String(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum DateTimeFilter {
		Equals(DateTime),
		InVec(Vec<DateTime>),
		NotInVec(Vec<DateTime>),
		Lt(DateTime),
		Lte(DateTime),
		Gt(DateTime),
		Gte(DateTime),
		Not(DateTime),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum DateTimeNullableFilter {
		Equals(Option<DateTime>),
		InVec(Vec<DateTime>),
		NotInVec(Vec<DateTime>),
		Lt(DateTime),
		Lte(DateTime),
		Gt(DateTime),
		Gte(DateTime),
		Not(Option<DateTime>),
	}
	impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeNullableFilter {
		fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
			match self {
				Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"equals".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
				Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"in".to_string(),
					::prisma_client_rust::PrismaValue::List(
						value
							.into_iter()
							.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
							.collect(),
					),
				)]),
				Self::NotInVec(value) => {
					::prisma_client_rust::SerializedWhereValue::Object(vec![(
						"notIn".to_string(),
						::prisma_client_rust::PrismaValue::List(
							value
								.into_iter()
								.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
								.collect(),
						),
					)])
				}
				Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lt".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"lte".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gt".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"gte".to_string(),
					::prisma_client_rust::PrismaValue::DateTime(value),
				)]),
				Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"not".to_string(),
					value
						.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
						.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				)]),
			}
		}
	}
}
pub mod write_params {
	use super::*;
	#[derive(Debug, Clone)]
	pub enum BigIntParam {
		Set(BigInt),
		Increment(BigInt),
		Decrement(BigInt),
		Multiply(BigInt),
		Divide(BigInt),
	}
	impl Into<::prisma_client_rust::PrismaValue> for BigIntParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => ::prisma_client_rust::PrismaValue::BigInt(value),
				Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"increment".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"decrement".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"multiply".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"divide".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BigIntNullableParam {
		Set(Option<BigInt>),
		Increment(BigInt),
		Decrement(BigInt),
		Multiply(BigInt),
		Divide(BigInt),
	}
	impl Into<::prisma_client_rust::PrismaValue> for BigIntNullableParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => value
					.map(|value| ::prisma_client_rust::PrismaValue::BigInt(value))
					.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"increment".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"decrement".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"multiply".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
				Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"divide".to_string(),
					::prisma_client_rust::PrismaValue::BigInt(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BooleanParam {
		Set(Boolean),
	}
	impl Into<::prisma_client_rust::PrismaValue> for BooleanParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => ::prisma_client_rust::PrismaValue::Boolean(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BooleanNullableParam {
		Set(Option<Boolean>),
	}
	impl Into<::prisma_client_rust::PrismaValue> for BooleanNullableParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => value
					.map(|value| ::prisma_client_rust::PrismaValue::Boolean(value))
					.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BytesParam {
		Set(Bytes),
	}
	impl Into<::prisma_client_rust::PrismaValue> for BytesParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => ::prisma_client_rust::PrismaValue::Bytes(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum BytesNullableParam {
		Set(Option<Bytes>),
	}
	impl Into<::prisma_client_rust::PrismaValue> for BytesNullableParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => value
					.map(|value| ::prisma_client_rust::PrismaValue::Bytes(value))
					.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum DateTimeParam {
		Set(DateTime),
	}
	impl Into<::prisma_client_rust::PrismaValue> for DateTimeParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => ::prisma_client_rust::PrismaValue::DateTime(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum DateTimeNullableParam {
		Set(Option<DateTime>),
	}
	impl Into<::prisma_client_rust::PrismaValue> for DateTimeNullableParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => value
					.map(|value| ::prisma_client_rust::PrismaValue::DateTime(value))
					.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum IntParam {
		Set(Int),
		Increment(Int),
		Decrement(Int),
		Multiply(Int),
		Divide(Int),
	}
	impl Into<::prisma_client_rust::PrismaValue> for IntParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => ::prisma_client_rust::PrismaValue::Int(value),
				Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"increment".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"decrement".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"multiply".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"divide".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum IntNullableParam {
		Set(Option<Int>),
		Increment(Int),
		Decrement(Int),
		Multiply(Int),
		Divide(Int),
	}
	impl Into<::prisma_client_rust::PrismaValue> for IntNullableParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => value
					.map(|value| ::prisma_client_rust::PrismaValue::Int(value))
					.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
				Self::Increment(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"increment".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Decrement(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"decrement".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Multiply(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"multiply".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
				Self::Divide(value) => ::prisma_client_rust::PrismaValue::Object(vec![(
					"divide".to_string(),
					::prisma_client_rust::PrismaValue::Int(value),
				)]),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum StringParam {
		Set(String),
	}
	impl Into<::prisma_client_rust::PrismaValue> for StringParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => ::prisma_client_rust::PrismaValue::String(value),
			}
		}
	}
	#[derive(Debug, Clone)]
	pub enum StringNullableParam {
		Set(Option<String>),
	}
	impl Into<::prisma_client_rust::PrismaValue> for StringNullableParam {
		fn into(self) -> ::prisma_client_rust::PrismaValue {
			match self {
				Self::Set(value) => value
					.map(|value| ::prisma_client_rust::PrismaValue::String(value))
					.unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
			}
		}
	}
}
