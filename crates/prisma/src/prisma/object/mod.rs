// File generated by Prisma Client Rust. DO NOT EDIT

pub mod albums;
pub mod date_accessed;
pub mod date_created;
pub mod exif_data;
pub mod favorite;
pub mod ffmpeg_data;
pub mod file_paths;
pub mod hidden;
pub mod id;
pub mod important;
pub mod key_id;
pub mod kind;
pub mod labels;
pub mod note;
pub mod pub_id;
pub mod spaces;
pub mod tags;
use super::{_prisma::*, *};
pub const NAME: &str = "Object";
#[derive(Debug, Clone)]
pub enum WhereParam {
	Not(Vec<WhereParam>),
	Or(Vec<WhereParam>),
	And(Vec<WhereParam>),
	Id(super::_prisma::read_filters::IntFilter),
	PubId(super::_prisma::read_filters::BytesFilter),
	Kind(super::_prisma::read_filters::IntNullableFilter),
	KeyId(super::_prisma::read_filters::IntNullableFilter),
	Hidden(super::_prisma::read_filters::BooleanNullableFilter),
	Favorite(super::_prisma::read_filters::BooleanNullableFilter),
	Important(super::_prisma::read_filters::BooleanNullableFilter),
	Note(super::_prisma::read_filters::StringNullableFilter),
	DateCreated(super::_prisma::read_filters::DateTimeNullableFilter),
	DateAccessed(super::_prisma::read_filters::DateTimeNullableFilter),
	TagsSome(Vec<super::tag_on_object::WhereParam>),
	TagsEvery(Vec<super::tag_on_object::WhereParam>),
	TagsNone(Vec<super::tag_on_object::WhereParam>),
	LabelsSome(Vec<super::label_on_object::WhereParam>),
	LabelsEvery(Vec<super::label_on_object::WhereParam>),
	LabelsNone(Vec<super::label_on_object::WhereParam>),
	AlbumsSome(Vec<super::object_in_album::WhereParam>),
	AlbumsEvery(Vec<super::object_in_album::WhereParam>),
	AlbumsNone(Vec<super::object_in_album::WhereParam>),
	SpacesSome(Vec<super::object_in_space::WhereParam>),
	SpacesEvery(Vec<super::object_in_space::WhereParam>),
	SpacesNone(Vec<super::object_in_space::WhereParam>),
	FilePathsSome(Vec<super::file_path::WhereParam>),
	FilePathsEvery(Vec<super::file_path::WhereParam>),
	FilePathsNone(Vec<super::file_path::WhereParam>),
	ExifDataIsNull,
	ExifDataIs(Vec<super::exif_data::WhereParam>),
	ExifDataIsNot(Vec<super::exif_data::WhereParam>),
	FfmpegDataIsNull,
	FfmpegDataIs(Vec<super::ffmpeg_data::WhereParam>),
	FfmpegDataIsNot(Vec<super::ffmpeg_data::WhereParam>),
}
impl ::prisma_client_rust::WhereInput for WhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			Self::Not(value) => (
				"NOT",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Or(value) => (
				"OR",
				::prisma_client_rust::SerializedWhereValue::List(
					value
						.into_iter()
						.map(::prisma_client_rust::WhereInput::serialize)
						.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
						.collect(),
				),
			),
			Self::And(value) => (
				"AND",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Id(value) => (id::NAME, value.into()),
			Self::PubId(value) => (pub_id::NAME, value.into()),
			Self::Kind(value) => (kind::NAME, value.into()),
			Self::KeyId(value) => (key_id::NAME, value.into()),
			Self::Hidden(value) => (hidden::NAME, value.into()),
			Self::Favorite(value) => (favorite::NAME, value.into()),
			Self::Important(value) => (important::NAME, value.into()),
			Self::Note(value) => (note::NAME, value.into()),
			Self::DateCreated(value) => (date_created::NAME, value.into()),
			Self::DateAccessed(value) => (date_accessed::NAME, value.into()),
			Self::TagsSome(where_params) => (
				tags::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::TagsEvery(where_params) => (
				tags::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::TagsNone(where_params) => (
				tags::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::LabelsSome(where_params) => (
				labels::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::LabelsEvery(where_params) => (
				labels::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::LabelsNone(where_params) => (
				labels::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::AlbumsSome(where_params) => (
				albums::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::AlbumsEvery(where_params) => (
				albums::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::AlbumsNone(where_params) => (
				albums::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::SpacesSome(where_params) => (
				spaces::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::SpacesEvery(where_params) => (
				spaces::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::SpacesNone(where_params) => (
				spaces::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::FilePathsSome(where_params) => (
				file_paths::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::FilePathsEvery(where_params) => (
				file_paths::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::FilePathsNone(where_params) => (
				file_paths::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ExifDataIsNull => (
				exif_data::NAME,
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Null,
				),
			),
			Self::ExifDataIs(where_params) => (
				exif_data::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ExifDataIsNot(where_params) => (
				exif_data::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::FfmpegDataIsNull => (
				ffmpeg_data::NAME,
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Null,
				),
			),
			Self::FfmpegDataIs(where_params) => (
				ffmpeg_data::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::FfmpegDataIsNot(where_params) => (
				ffmpeg_data::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
#[derive(Debug, Clone)]
pub enum UniqueWhereParam {
	PubIdEquals(Bytes),
	IdEquals(Int),
}
impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			UniqueWhereParam::PubIdEquals(value) => (
				"pub_id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Bytes(value),
				),
			),
			UniqueWhereParam::IdEquals(value) => (
				"id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
	fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
		match op {
			::prisma_client_rust::Operator::Not(value) => Self::Not(value),
			::prisma_client_rust::Operator::And(value) => Self::And(value),
			::prisma_client_rust::Operator::Or(value) => Self::Or(value),
		}
	}
}
#[derive(Debug, Clone)]
pub enum OrderByWithRelationParam {
	Id(super::SortOrder),
	PubId(super::SortOrder),
	Kind(super::SortOrder),
	KeyId(super::SortOrder),
	Hidden(super::SortOrder),
	Favorite(super::SortOrder),
	Important(super::SortOrder),
	Note(super::SortOrder),
	DateCreated(super::SortOrder),
	DateAccessed(super::SortOrder),
	Tags(Vec<super::tag_on_object::OrderByRelationAggregateParam>),
	Labels(Vec<super::label_on_object::OrderByRelationAggregateParam>),
	Albums(Vec<super::object_in_album::OrderByRelationAggregateParam>),
	Spaces(Vec<super::object_in_space::OrderByRelationAggregateParam>),
	FilePaths(Vec<super::file_path::OrderByRelationAggregateParam>),
	ExifData(Vec<super::exif_data::OrderByWithRelationParam>),
	FfmpegData(Vec<super::ffmpeg_data::OrderByWithRelationParam>),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(param) => ("id", param.into()),
			Self::PubId(param) => ("pub_id", param.into()),
			Self::Kind(param) => ("kind", param.into()),
			Self::KeyId(param) => ("key_id", param.into()),
			Self::Hidden(param) => ("hidden", param.into()),
			Self::Favorite(param) => ("favorite", param.into()),
			Self::Important(param) => ("important", param.into()),
			Self::Note(param) => ("note", param.into()),
			Self::DateCreated(param) => ("date_created", param.into()),
			Self::DateAccessed(param) => ("date_accessed", param.into()),
			Self::Tags(param) => (
				"tags",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::Labels(param) => (
				"labels",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::Albums(param) => (
				"albums",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::Spaces(param) => (
				"spaces",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::FilePaths(param) => (
				"file_paths",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::ExifData(param) => (
				"exif_data",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::FfmpegData(param) => (
				"ffmpeg_data",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum WithParam {
	Tags(super::tag_on_object::ManyArgs),
	Labels(super::label_on_object::ManyArgs),
	Albums(super::object_in_album::ManyArgs),
	Spaces(super::object_in_space::ManyArgs),
	FilePaths(super::file_path::ManyArgs),
	ExifData(super::exif_data::UniqueArgs),
	FfmpegData(super::ffmpeg_data::UniqueArgs),
}
impl Into<::prisma_client_rust::Selection> for WithParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Tags(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: tag_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(tags::NAME, None, arguments, nested_selections)
			}
			Self::Labels(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: label_on_object :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(
					labels::NAME,
					None,
					arguments,
					nested_selections,
				)
			}
			Self::Albums(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: object_in_album :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(
					albums::NAME,
					None,
					arguments,
					nested_selections,
				)
			}
			Self::Spaces(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: object_in_space :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(
					spaces::NAME,
					None,
					arguments,
					nested_selections,
				)
			}
			Self::FilePaths(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: file_path :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(
					file_paths::NAME,
					None,
					arguments,
					nested_selections,
				)
			}
			Self::ExifData(args) => {
				let mut selections = < super :: exif_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(exif_data::NAME, None, [], selections)
			}
			Self::FfmpegData(args) => {
				let mut selections = < super :: ffmpeg_data :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ;
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(ffmpeg_data::NAME, None, [], selections)
			}
		}
	}
}
#[derive(Debug, Clone)]
pub enum SetParam {
	Id(super::_prisma::write_params::IntParam),
	PubId(super::_prisma::write_params::BytesParam),
	Kind(super::_prisma::write_params::IntNullableParam),
	KeyId(super::_prisma::write_params::IntNullableParam),
	Hidden(super::_prisma::write_params::BooleanNullableParam),
	Favorite(super::_prisma::write_params::BooleanNullableParam),
	Important(super::_prisma::write_params::BooleanNullableParam),
	Note(super::_prisma::write_params::StringNullableParam),
	DateCreated(super::_prisma::write_params::DateTimeNullableParam),
	DateAccessed(super::_prisma::write_params::DateTimeNullableParam),
	ConnectTags(Vec<super::tag_on_object::UniqueWhereParam>),
	DisconnectTags(Vec<super::tag_on_object::UniqueWhereParam>),
	SetTags(Vec<super::tag_on_object::UniqueWhereParam>),
	ConnectLabels(Vec<super::label_on_object::UniqueWhereParam>),
	DisconnectLabels(Vec<super::label_on_object::UniqueWhereParam>),
	SetLabels(Vec<super::label_on_object::UniqueWhereParam>),
	ConnectAlbums(Vec<super::object_in_album::UniqueWhereParam>),
	DisconnectAlbums(Vec<super::object_in_album::UniqueWhereParam>),
	SetAlbums(Vec<super::object_in_album::UniqueWhereParam>),
	ConnectSpaces(Vec<super::object_in_space::UniqueWhereParam>),
	DisconnectSpaces(Vec<super::object_in_space::UniqueWhereParam>),
	SetSpaces(Vec<super::object_in_space::UniqueWhereParam>),
	ConnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
	DisconnectFilePaths(Vec<super::file_path::UniqueWhereParam>),
	SetFilePaths(Vec<super::file_path::UniqueWhereParam>),
	ConnectExifData(super::exif_data::UniqueWhereParam),
	DisconnectExifData,
	ConnectFfmpegData(super::ffmpeg_data::UniqueWhereParam),
	DisconnectFfmpegData,
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => (id::NAME, value.into()),
			Self::PubId(value) => (pub_id::NAME, value.into()),
			Self::Kind(value) => (kind::NAME, value.into()),
			Self::KeyId(value) => (key_id::NAME, value.into()),
			Self::Hidden(value) => (hidden::NAME, value.into()),
			Self::Favorite(value) => (favorite::NAME, value.into()),
			Self::Important(value) => (important::NAME, value.into()),
			Self::Note(value) => (note::NAME, value.into()),
			Self::DateCreated(value) => (date_created::NAME, value.into()),
			Self::DateAccessed(value) => (date_accessed::NAME, value.into()),
			Self::ConnectTags(where_params) => (
				tags::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectTags(where_params) => (
				tags::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetTags(where_params) => (
				tags::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::ConnectLabels(where_params) => (
				labels::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectLabels(where_params) => (
				labels::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetLabels(where_params) => (
				labels::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::ConnectAlbums(where_params) => (
				albums::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectAlbums(where_params) => (
				albums::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetAlbums(where_params) => (
				albums::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::ConnectSpaces(where_params) => (
				spaces::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectSpaces(where_params) => (
				spaces::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetSpaces(where_params) => (
				spaces::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::ConnectFilePaths(where_params) => (
				file_paths::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectFilePaths(where_params) => (
				file_paths::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetFilePaths(where_params) => (
				file_paths::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::ConnectExifData(where_param) => (
				exif_data::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::DisconnectExifData => (
				exif_data::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(true),
				)]),
			),
			Self::ConnectFfmpegData(where_param) => (
				ffmpeg_data::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::DisconnectFfmpegData => (
				ffmpeg_data::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::Boolean(true),
				)]),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum UncheckedSetParam {
	Id(super::_prisma::write_params::IntParam),
	PubId(super::_prisma::write_params::BytesParam),
	Kind(super::_prisma::write_params::IntNullableParam),
	KeyId(super::_prisma::write_params::IntNullableParam),
	Hidden(super::_prisma::write_params::BooleanNullableParam),
	Favorite(super::_prisma::write_params::BooleanNullableParam),
	Important(super::_prisma::write_params::BooleanNullableParam),
	Note(super::_prisma::write_params::StringNullableParam),
	DateCreated(super::_prisma::write_params::DateTimeNullableParam),
	DateAccessed(super::_prisma::write_params::DateTimeNullableParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => ("id", value.into()),
			Self::PubId(value) => ("pub_id", value.into()),
			Self::Kind(value) => ("kind", value.into()),
			Self::KeyId(value) => ("key_id", value.into()),
			Self::Hidden(value) => ("hidden", value.into()),
			Self::Favorite(value) => ("favorite", value.into()),
			Self::Important(value) => ("important", value.into()),
			Self::Note(value) => ("note", value.into()),
			Self::DateCreated(value) => ("date_created", value.into()),
			Self::DateAccessed(value) => ("date_accessed", value.into()),
		};
		(k.to_string(), v)
	}
}
::prisma_client_rust::macros::select_factory!(
	_select_object,
	select,
	prisma::object,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "pub_id")]
		pub_id: pub_id::Type,
		#[serde(rename = "kind")]
		kind: kind::Type,
		#[serde(rename = "key_id")]
		key_id: key_id::Type,
		#[serde(rename = "hidden")]
		hidden: hidden::Type,
		#[serde(rename = "favorite")]
		favorite: favorite::Type,
		#[serde(rename = "important")]
		important: important::Type,
		#[serde(rename = "note")]
		note: note::Type,
		#[serde(rename = "date_created")]
		date_created: date_created::Type,
		#[serde(rename = "date_accessed")]
		date_accessed: date_accessed::Type,
		#[serde(rename = "tags")]
		tags: tags::Type,
		#[serde(rename = "labels")]
		labels: labels::Type,
		#[serde(rename = "albums")]
		albums: albums::Type,
		#[serde(rename = "spaces")]
		spaces: spaces::Type,
		#[serde(rename = "file_paths")]
		file_paths: file_paths::Type,
		#[serde(rename = "exif_data")]
		exif_data: exif_data::Type,
		#[serde(rename = "ffmpeg_data")]
		ffmpeg_data: ffmpeg_data::Type,
	},
	[
		(id, Scalar),
		(pub_id, Scalar),
		(kind, Scalar),
		(key_id, Scalar),
		(hidden, Scalar),
		(favorite, Scalar),
		(important, Scalar),
		(note, Scalar),
		(date_created, Scalar),
		(date_accessed, Scalar),
		(tags, Relation(prisma::tag_on_object, Many)),
		(labels, Relation(prisma::label_on_object, Many)),
		(albums, Relation(prisma::object_in_album, Many)),
		(spaces, Relation(prisma::object_in_space, Many)),
		(file_paths, Relation(prisma::file_path, Many)),
		(exif_data, Relation(prisma::exif_data, Optional)),
		(ffmpeg_data, Relation(prisma::ffmpeg_data, Optional))
	]
);
pub enum SelectParam {
	Id(id::Select),
	PubId(pub_id::Select),
	Kind(kind::Select),
	KeyId(key_id::Select),
	Hidden(hidden::Select),
	Favorite(favorite::Select),
	Important(important::Select),
	Note(note::Select),
	DateCreated(date_created::Select),
	DateAccessed(date_accessed::Select),
	Tags(tags::Select),
	Labels(labels::Select),
	Albums(albums::Select),
	Spaces(spaces::Select),
	FilePaths(file_paths::Select),
	ExifData(exif_data::Select),
	FfmpegData(ffmpeg_data::Select),
}
impl Into<::prisma_client_rust::Selection> for SelectParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::PubId(data) => data.into(),
			Self::Kind(data) => data.into(),
			Self::KeyId(data) => data.into(),
			Self::Hidden(data) => data.into(),
			Self::Favorite(data) => data.into(),
			Self::Important(data) => data.into(),
			Self::Note(data) => data.into(),
			Self::DateCreated(data) => data.into(),
			Self::DateAccessed(data) => data.into(),
			Self::Tags(data) => data.into(),
			Self::Labels(data) => data.into(),
			Self::Albums(data) => data.into(),
			Self::Spaces(data) => data.into(),
			Self::FilePaths(data) => data.into(),
			Self::ExifData(data) => data.into(),
			Self::FfmpegData(data) => data.into(),
		}
	}
}
::prisma_client_rust::macros::include_factory!(
	_include_object,
	include,
	prisma::object,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "pub_id")]
		pub_id: pub_id::Type,
		#[serde(rename = "kind")]
		kind: kind::Type,
		#[serde(rename = "key_id")]
		key_id: key_id::Type,
		#[serde(rename = "hidden")]
		hidden: hidden::Type,
		#[serde(rename = "favorite")]
		favorite: favorite::Type,
		#[serde(rename = "important")]
		important: important::Type,
		#[serde(rename = "note")]
		note: note::Type,
		#[serde(rename = "date_created")]
		date_created: date_created::Type,
		#[serde(rename = "date_accessed")]
		date_accessed: date_accessed::Type,
		#[serde(rename = "tags")]
		tags: tags::Type,
		#[serde(rename = "labels")]
		labels: labels::Type,
		#[serde(rename = "albums")]
		albums: albums::Type,
		#[serde(rename = "spaces")]
		spaces: spaces::Type,
		#[serde(rename = "file_paths")]
		file_paths: file_paths::Type,
		#[serde(rename = "exif_data")]
		exif_data: exif_data::Type,
		#[serde(rename = "ffmpeg_data")]
		ffmpeg_data: ffmpeg_data::Type,
	},
	[
		(tags, Relation(prisma::tag_on_object, Many)),
		(labels, Relation(prisma::label_on_object, Many)),
		(albums, Relation(prisma::object_in_album, Many)),
		(spaces, Relation(prisma::object_in_space, Many)),
		(file_paths, Relation(prisma::file_path, Many)),
		(exif_data, Relation(prisma::exif_data, Optional)),
		(ffmpeg_data, Relation(prisma::ffmpeg_data, Optional))
	]
);
pub enum IncludeParam {
	Id(id::Include),
	PubId(pub_id::Include),
	Kind(kind::Include),
	KeyId(key_id::Include),
	Hidden(hidden::Include),
	Favorite(favorite::Include),
	Important(important::Include),
	Note(note::Include),
	DateCreated(date_created::Include),
	DateAccessed(date_accessed::Include),
	Tags(tags::Include),
	Labels(labels::Include),
	Albums(albums::Include),
	Spaces(spaces::Include),
	FilePaths(file_paths::Include),
	ExifData(exif_data::Include),
	FfmpegData(ffmpeg_data::Include),
}
impl Into<::prisma_client_rust::Selection> for IncludeParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::PubId(data) => data.into(),
			Self::Kind(data) => data.into(),
			Self::KeyId(data) => data.into(),
			Self::Hidden(data) => data.into(),
			Self::Favorite(data) => data.into(),
			Self::Important(data) => data.into(),
			Self::Note(data) => data.into(),
			Self::DateCreated(data) => data.into(),
			Self::DateAccessed(data) => data.into(),
			Self::Tags(data) => data.into(),
			Self::Labels(data) => data.into(),
			Self::Albums(data) => data.into(),
			Self::Spaces(data) => data.into(),
			Self::FilePaths(data) => data.into(),
			Self::ExifData(data) => data.into(),
			Self::FfmpegData(data) => data.into(),
		}
	}
}
#[derive(Debug, Clone)]
pub struct Create {
	pub pub_id: Bytes,
	pub _params: Vec<SetParam>,
}
impl Create {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
		client.object().create(self.pub_id, self._params)
	}
	pub fn to_params(mut self) -> Vec<SetParam> {
		self._params.extend([pub_id::set(self.pub_id)]);
		self._params
	}
}
pub fn create(pub_id: Bytes, _params: Vec<SetParam>) -> Create {
	Create { pub_id, _params }
}
#[derive(Debug, Clone)]
pub struct CreateUnchecked {
	pub pub_id: Bytes,
	pub _params: Vec<UncheckedSetParam>,
}
impl CreateUnchecked {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
		client.object().create_unchecked(self.pub_id, self._params)
	}
	pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
		self._params.extend([pub_id::set(self.pub_id)]);
		self._params
	}
}
pub fn create_unchecked(pub_id: Bytes, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
	CreateUnchecked { pub_id, _params }
}
#[derive(Debug, Clone)]
pub struct Types;
impl ::prisma_client_rust::ModelTypes for Types {
	type Data = Data;
	type Where = WhereParam;
	type WhereUnique = UniqueWhereParam;
	type UncheckedSet = UncheckedSetParam;
	type Set = SetParam;
	type With = WithParam;
	type OrderBy = OrderByWithRelationParam;
	type Cursor = UniqueWhereParam;
	const MODEL: &'static str = NAME;
	fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
		vec![
			::prisma_client_rust::sel(id::NAME),
			::prisma_client_rust::sel(pub_id::NAME),
			::prisma_client_rust::sel(kind::NAME),
			::prisma_client_rust::sel(key_id::NAME),
			::prisma_client_rust::sel(hidden::NAME),
			::prisma_client_rust::sel(favorite::NAME),
			::prisma_client_rust::sel(important::NAME),
			::prisma_client_rust::sel(note::NAME),
			::prisma_client_rust::sel(date_created::NAME),
			::prisma_client_rust::sel(date_accessed::NAME),
		]
	}
}
#[derive(
	Debug,
	Clone,
	:: serde :: Serialize,
	:: serde :: Deserialize,
	:: prisma_client_rust :: specta :: Type,
)]
# [specta (rename = "Object" , crate = prisma_client_rust :: specta)]
pub struct Data {
	#[serde(rename = "id")]
	pub id: id::Type,
	#[serde(rename = "pub_id")]
	pub pub_id: pub_id::Type,
	#[serde(rename = "kind")]
	pub kind: kind::Type,
	#[serde(rename = "key_id")]
	pub key_id: key_id::Type,
	#[serde(rename = "hidden")]
	pub hidden: hidden::Type,
	#[serde(rename = "favorite")]
	pub favorite: favorite::Type,
	#[serde(rename = "important")]
	pub important: important::Type,
	#[serde(rename = "note")]
	pub note: note::Type,
	#[serde(rename = "date_created")]
	pub date_created: date_created::Type,
	#[serde(rename = "date_accessed")]
	pub date_accessed: date_accessed::Type,
	#[serde(rename = "tags")]
	#[specta(skip)]
	pub tags: Option<tags::RecursiveSafeType>,
	#[serde(rename = "labels")]
	#[specta(skip)]
	pub labels: Option<labels::RecursiveSafeType>,
	#[serde(rename = "albums")]
	#[specta(skip)]
	pub albums: Option<albums::RecursiveSafeType>,
	#[serde(rename = "spaces")]
	#[specta(skip)]
	pub spaces: Option<spaces::RecursiveSafeType>,
	#[serde(rename = "file_paths")]
	#[specta(skip)]
	pub file_paths: Option<file_paths::RecursiveSafeType>,
	#[serde(
		rename = "exif_data",
		default,
		skip_serializing_if = "Option::is_none",
		with = "prisma_client_rust::serde::double_option"
	)]
	#[specta(skip)]
	pub exif_data: Option<exif_data::RecursiveSafeType>,
	#[serde(
		rename = "ffmpeg_data",
		default,
		skip_serializing_if = "Option::is_none",
		with = "prisma_client_rust::serde::double_option"
	)]
	#[specta(skip)]
	pub ffmpeg_data: Option<ffmpeg_data::RecursiveSafeType>,
}
impl Data {
	pub fn tags(&self) -> Result<&tags::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.tags
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(tags),
			))
	}
	pub fn labels(&self) -> Result<&labels::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.labels
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(labels),
			))
	}
	pub fn albums(&self) -> Result<&albums::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.albums
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(albums),
			))
	}
	pub fn spaces(&self) -> Result<&spaces::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.spaces
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(spaces),
			))
	}
	pub fn file_paths(
		&self,
	) -> Result<&file_paths::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.file_paths
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(file_paths),
			))
	}
	pub fn exif_data(
		&self,
	) -> Result<Option<&super::exif_data::Data>, ::prisma_client_rust::RelationNotFetchedError> {
		self.exif_data
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(exif_data),
			))
			.map(|v| v.as_ref().map(|v| v.as_ref()))
	}
	pub fn ffmpeg_data(
		&self,
	) -> Result<Option<&super::ffmpeg_data::Data>, ::prisma_client_rust::RelationNotFetchedError> {
		self.ffmpeg_data
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(ffmpeg_data),
			))
			.map(|v| v.as_ref().map(|v| v.as_ref()))
	}
}
::prisma_client_rust::macros::partial_unchecked_factory!(
	_partial_unchecked_object,
	prisma::object,
	struct Data {
		#[serde(rename = "id")]
		pub id: prisma::object::id::Type,
		#[serde(rename = "pub_id")]
		pub pub_id: prisma::object::pub_id::Type,
		#[serde(rename = "kind")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub kind: prisma::object::kind::Type,
		#[serde(rename = "key_id")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub key_id: prisma::object::key_id::Type,
		#[serde(rename = "hidden")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub hidden: prisma::object::hidden::Type,
		#[serde(rename = "favorite")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub favorite: prisma::object::favorite::Type,
		#[serde(rename = "important")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub important: prisma::object::important::Type,
		#[serde(rename = "note")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub note: prisma::object::note::Type,
		#[serde(rename = "date_created")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub date_created: prisma::object::date_created::Type,
		#[serde(rename = "date_accessed")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub date_accessed: prisma::object::date_accessed::Type,
	}
);
::prisma_client_rust::macros::filter_factory!(
	_object_filter,
	prisma::object,
	[
		(id, Scalar),
		(pub_id, Scalar),
		(kind, Scalar),
		(key_id, Scalar),
		(hidden, Scalar),
		(favorite, Scalar),
		(important, Scalar),
		(note, Scalar),
		(date_created, Scalar),
		(date_accessed, Scalar),
		(tags, Relation(prisma::tag_on_object, Many)),
		(labels, Relation(prisma::label_on_object, Many)),
		(albums, Relation(prisma::object_in_album, Many)),
		(spaces, Relation(prisma::object_in_space, Many)),
		(file_paths, Relation(prisma::file_path, Many)),
		(exif_data, Relation(prisma::exif_data, Optional)),
		(ffmpeg_data, Relation(prisma::ffmpeg_data, Optional))
	]
);
pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
#[derive(Clone)]
pub struct Actions<'a> {
	pub client: &'a ::prisma_client_rust::PrismaClientInternals,
}
impl<'a> Actions<'a> {
	pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
		FindUniqueQuery::new(self.client, _where)
	}
	pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
		FindFirstQuery::new(self.client, _where)
	}
	pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
		FindManyQuery::new(self.client, _where)
	}
	pub fn create(self, pub_id: Bytes, mut _params: Vec<SetParam>) -> CreateQuery<'a> {
		_params.extend([pub_id::set(pub_id)]);
		CreateQuery::new(self.client, _params)
	}
	pub fn create_unchecked(
		self,
		pub_id: Bytes,
		mut _params: Vec<UncheckedSetParam>,
	) -> CreateUncheckedQuery<'a> {
		_params.extend([pub_id::set(pub_id)]);
		CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
	}
	pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
		let data = data.into_iter().map(CreateUnchecked::to_params).collect();
		CreateManyQuery::new(self.client, data)
	}
	pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
		UpdateQuery::new(self.client, _where, _params, vec![])
	}
	pub fn update_unchecked(
		self,
		_where: UniqueWhereParam,
		_params: Vec<UncheckedSetParam>,
	) -> UpdateUncheckedQuery<'a> {
		UpdateUncheckedQuery::new(
			self.client,
			_where,
			_params.into_iter().map(Into::into).collect(),
			vec![],
		)
	}
	pub fn update_many(
		self,
		_where: Vec<WhereParam>,
		_params: Vec<SetParam>,
	) -> UpdateManyQuery<'a> {
		UpdateManyQuery::new(self.client, _where, _params)
	}
	pub fn upsert(
		self,
		_where: UniqueWhereParam,
		_create: Create,
		_update: Vec<SetParam>,
	) -> UpsertQuery<'a> {
		UpsertQuery::new(self.client, _where, _create.to_params(), _update)
	}
	pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
		DeleteQuery::new(self.client, _where, vec![])
	}
	pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
		DeleteManyQuery::new(self.client, _where)
	}
	pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
		CountQuery::new(self.client, _where)
	}
}
