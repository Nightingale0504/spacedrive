// File generated by Prisma Client Rust. DO NOT EDIT

use super::super::{_prisma::*, *};
use super::{SetParam, UncheckedSetParam, UniqueWhereParam, WhereParam, WithParam};
pub const NAME: &str = "indexer_rules";
pub type Type = Vec<indexer_rules_in_location::Data>;
pub type RecursiveSafeType = Type;
pub fn some(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
	WhereParam::IndexerRulesSome(value)
}
pub fn every(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
	WhereParam::IndexerRulesEvery(value)
}
pub fn none(value: Vec<indexer_rules_in_location::WhereParam>) -> WhereParam {
	WhereParam::IndexerRulesNone(value)
}
pub struct Order(Vec<indexer_rules_in_location::OrderByRelationAggregateParam>);
pub fn order<T: From<Order>>(
	v: Vec<indexer_rules_in_location::OrderByRelationAggregateParam>,
) -> T {
	Order(v).into()
}
impl From<Order> for super::OrderByWithRelationParam {
	fn from(Order(v): Order) -> Self {
		Self::IndexerRules(v)
	}
}
pub struct Fetch(pub indexer_rules_in_location::ManyArgs);
impl Fetch {
	pub fn with(mut self, params: impl Into<indexer_rules_in_location::WithParam>) -> Self {
		self.0 = self.0.with(params.into());
		self
	}
	pub fn order_by(mut self, param: indexer_rules_in_location::OrderByWithRelationParam) -> Self {
		self.0 = self.0.order_by(param);
		self
	}
	pub fn skip(mut self, value: i64) -> Self {
		self.0 = self.0.skip(value);
		self
	}
	pub fn take(mut self, value: i64) -> Self {
		self.0 = self.0.take(value);
		self
	}
	pub fn cursor(mut self, value: indexer_rules_in_location::UniqueWhereParam) -> Self {
		self.0 = self.0.cursor(value.into());
		self
	}
}
impl From<Fetch> for WithParam {
	fn from(Fetch(v): Fetch) -> Self {
		WithParam::IndexerRules(v)
	}
}
pub fn fetch(params: Vec<indexer_rules_in_location::WhereParam>) -> Fetch {
	Fetch(indexer_rules_in_location::ManyArgs::new(params))
}
pub struct Connect(pub Vec<indexer_rules_in_location::UniqueWhereParam>);
impl From<Connect> for SetParam {
	fn from(Connect(v): Connect) -> Self {
		Self::ConnectIndexerRules(v)
	}
}
pub fn connect<T: From<Connect>>(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> T {
	Connect(params).into()
}
pub fn disconnect(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
	SetParam::DisconnectIndexerRules(params)
}
pub fn set(params: Vec<indexer_rules_in_location::UniqueWhereParam>) -> SetParam {
	SetParam::SetIndexerRules(params)
}
pub enum Select {
	Select(
		indexer_rules_in_location::ManyArgs,
		Vec<indexer_rules_in_location::SelectParam>,
	),
	Include(
		indexer_rules_in_location::ManyArgs,
		Vec<indexer_rules_in_location::IncludeParam>,
	),
	Fetch(indexer_rules_in_location::ManyArgs),
}
impl Into<super::SelectParam> for Select {
	fn into(self) -> super::SelectParam {
		super::SelectParam::IndexerRules(self)
	}
}
impl Select {
	pub fn select(
		args: indexer_rules_in_location::ManyArgs,
		nested_selections: Vec<indexer_rules_in_location::SelectParam>,
	) -> Self {
		Self::Select(args, nested_selections)
	}
	pub fn include(
		args: indexer_rules_in_location::ManyArgs,
		nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
	) -> Self {
		Self::Include(args, nested_selections)
	}
}
impl Into<::prisma_client_rust::Selection> for Select {
	fn into(self) -> ::prisma_client_rust::Selection {
		let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
		::prisma_client_rust::Selection::new(NAME, None, args, selections)
	}
}
pub enum Include {
	Select(
		indexer_rules_in_location::ManyArgs,
		Vec<indexer_rules_in_location::SelectParam>,
	),
	Include(
		indexer_rules_in_location::ManyArgs,
		Vec<indexer_rules_in_location::IncludeParam>,
	),
	Fetch(indexer_rules_in_location::ManyArgs),
}
impl Into<super::IncludeParam> for Include {
	fn into(self) -> super::IncludeParam {
		super::IncludeParam::IndexerRules(self)
	}
}
impl Include {
	pub fn select(
		args: indexer_rules_in_location::ManyArgs,
		nested_selections: Vec<indexer_rules_in_location::SelectParam>,
	) -> Self {
		Self::Select(args, nested_selections)
	}
	pub fn include(
		args: indexer_rules_in_location::ManyArgs,
		nested_selections: Vec<indexer_rules_in_location::IncludeParam>,
	) -> Self {
		Self::Include(args, nested_selections)
	}
}
impl Into<::prisma_client_rust::Selection> for Include {
	fn into(self) -> ::prisma_client_rust::Selection {
		let (args , selections) = match self { Self :: Select (args , selections) => (args . to_graphql () . 0 , selections . into_iter () . map (Into :: into) . collect ()) , Self :: Include (args , selections) => (args . to_graphql () . 0 , { let mut nested_selections = < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (Into :: into)) ; nested_selections }) , Self :: Fetch (args) => (args . to_graphql () . 0 , < indexer_rules_in_location :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) } ;
		::prisma_client_rust::Selection::new(NAME, None, args, selections)
	}
}
