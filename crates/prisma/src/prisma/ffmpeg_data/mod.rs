// File generated by Prisma Client Rust. DO NOT EDIT

pub mod album;
pub mod album_artist;
pub mod artist;
pub mod bit_rate;
pub mod chapters;
pub mod creation_time;
pub mod date;
pub mod disc;
pub mod duration;
pub mod formats;
pub mod id;
pub mod metadata;
pub mod object;
pub mod object_id;
pub mod programs;
pub mod start_time;
pub mod title;
pub mod track;
use super::{_prisma::*, *};
pub const NAME: &str = "FfmpegData";
#[derive(Debug, Clone)]
pub enum WhereParam {
	Not(Vec<WhereParam>),
	Or(Vec<WhereParam>),
	And(Vec<WhereParam>),
	Id(super::_prisma::read_filters::IntFilter),
	Formats(super::_prisma::read_filters::StringFilter),
	BitRate(super::_prisma::read_filters::BytesFilter),
	Duration(super::_prisma::read_filters::BytesNullableFilter),
	StartTime(super::_prisma::read_filters::BytesNullableFilter),
	ChaptersSome(Vec<super::ffmpeg_media_chapter::WhereParam>),
	ChaptersEvery(Vec<super::ffmpeg_media_chapter::WhereParam>),
	ChaptersNone(Vec<super::ffmpeg_media_chapter::WhereParam>),
	ProgramsSome(Vec<super::ffmpeg_media_program::WhereParam>),
	ProgramsEvery(Vec<super::ffmpeg_media_program::WhereParam>),
	ProgramsNone(Vec<super::ffmpeg_media_program::WhereParam>),
	Title(super::_prisma::read_filters::StringNullableFilter),
	CreationTime(super::_prisma::read_filters::DateTimeNullableFilter),
	Date(super::_prisma::read_filters::DateTimeNullableFilter),
	AlbumArtist(super::_prisma::read_filters::StringNullableFilter),
	Disc(super::_prisma::read_filters::StringNullableFilter),
	Track(super::_prisma::read_filters::StringNullableFilter),
	Album(super::_prisma::read_filters::StringNullableFilter),
	Artist(super::_prisma::read_filters::StringNullableFilter),
	Metadata(super::_prisma::read_filters::BytesNullableFilter),
	ObjectIs(Vec<super::object::WhereParam>),
	ObjectIsNot(Vec<super::object::WhereParam>),
	ObjectId(super::_prisma::read_filters::IntFilter),
}
impl ::prisma_client_rust::WhereInput for WhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			Self::Not(value) => (
				"NOT",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Or(value) => (
				"OR",
				::prisma_client_rust::SerializedWhereValue::List(
					value
						.into_iter()
						.map(::prisma_client_rust::WhereInput::serialize)
						.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
						.collect(),
				),
			),
			Self::And(value) => (
				"AND",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Id(value) => (id::NAME, value.into()),
			Self::Formats(value) => (formats::NAME, value.into()),
			Self::BitRate(value) => (bit_rate::NAME, value.into()),
			Self::Duration(value) => (duration::NAME, value.into()),
			Self::StartTime(value) => (start_time::NAME, value.into()),
			Self::ChaptersSome(where_params) => (
				chapters::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ChaptersEvery(where_params) => (
				chapters::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ChaptersNone(where_params) => (
				chapters::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ProgramsSome(where_params) => (
				programs::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"some".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ProgramsEvery(where_params) => (
				programs::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"every".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ProgramsNone(where_params) => (
				programs::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"none".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::Title(value) => (title::NAME, value.into()),
			Self::CreationTime(value) => (creation_time::NAME, value.into()),
			Self::Date(value) => (date::NAME, value.into()),
			Self::AlbumArtist(value) => (album_artist::NAME, value.into()),
			Self::Disc(value) => (disc::NAME, value.into()),
			Self::Track(value) => (track::NAME, value.into()),
			Self::Album(value) => (album::NAME, value.into()),
			Self::Artist(value) => (artist::NAME, value.into()),
			Self::Metadata(value) => (metadata::NAME, value.into()),
			Self::ObjectIs(where_params) => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ObjectIsNot(where_params) => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ObjectId(value) => (object_id::NAME, value.into()),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
#[derive(Debug, Clone)]
pub enum UniqueWhereParam {
	ObjectIdEquals(Int),
	IdEquals(Int),
}
impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			UniqueWhereParam::ObjectIdEquals(value) => (
				"object_id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
			UniqueWhereParam::IdEquals(value) => (
				"id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
	fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
		match op {
			::prisma_client_rust::Operator::Not(value) => Self::Not(value),
			::prisma_client_rust::Operator::And(value) => Self::And(value),
			::prisma_client_rust::Operator::Or(value) => Self::Or(value),
		}
	}
}
#[derive(Debug, Clone)]
pub enum OrderByWithRelationParam {
	Id(super::SortOrder),
	Formats(super::SortOrder),
	BitRate(super::SortOrder),
	Duration(super::SortOrder),
	StartTime(super::SortOrder),
	Title(super::SortOrder),
	CreationTime(super::SortOrder),
	Date(super::SortOrder),
	AlbumArtist(super::SortOrder),
	Disc(super::SortOrder),
	Track(super::SortOrder),
	Album(super::SortOrder),
	Artist(super::SortOrder),
	Metadata(super::SortOrder),
	ObjectId(super::SortOrder),
	Chapters(Vec<super::ffmpeg_media_chapter::OrderByRelationAggregateParam>),
	Programs(Vec<super::ffmpeg_media_program::OrderByRelationAggregateParam>),
	Object(Vec<super::object::OrderByWithRelationParam>),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(param) => ("id", param.into()),
			Self::Formats(param) => ("formats", param.into()),
			Self::BitRate(param) => ("bit_rate", param.into()),
			Self::Duration(param) => ("duration", param.into()),
			Self::StartTime(param) => ("start_time", param.into()),
			Self::Title(param) => ("title", param.into()),
			Self::CreationTime(param) => ("creation_time", param.into()),
			Self::Date(param) => ("date", param.into()),
			Self::AlbumArtist(param) => ("album_artist", param.into()),
			Self::Disc(param) => ("disc", param.into()),
			Self::Track(param) => ("track", param.into()),
			Self::Album(param) => ("album", param.into()),
			Self::Artist(param) => ("artist", param.into()),
			Self::Metadata(param) => ("metadata", param.into()),
			Self::ObjectId(param) => ("object_id", param.into()),
			Self::Chapters(param) => (
				"chapters",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::Programs(param) => (
				"programs",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
			Self::Object(param) => (
				"object",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum WithParam {
	Chapters(super::ffmpeg_media_chapter::ManyArgs),
	Programs(super::ffmpeg_media_program::ManyArgs),
	Object(super::object::UniqueArgs),
}
impl Into<::prisma_client_rust::Selection> for WithParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Chapters(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: ffmpeg_media_chapter :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(
					chapters::NAME,
					None,
					arguments,
					nested_selections,
				)
			}
			Self::Programs(args) => {
				let (arguments, mut nested_selections) = args.to_graphql();
				nested_selections . extend (< super :: ffmpeg_media_program :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()) ;
				::prisma_client_rust::Selection::new(
					programs::NAME,
					None,
					arguments,
					nested_selections,
				)
			}
			Self::Object(args) => {
				let mut selections =
					<super::object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
			}
		}
	}
}
#[derive(Debug, Clone)]
pub enum SetParam {
	Id(super::_prisma::write_params::IntParam),
	Formats(super::_prisma::write_params::StringParam),
	BitRate(super::_prisma::write_params::BytesParam),
	Duration(super::_prisma::write_params::BytesNullableParam),
	StartTime(super::_prisma::write_params::BytesNullableParam),
	ConnectChapters(Vec<super::ffmpeg_media_chapter::UniqueWhereParam>),
	DisconnectChapters(Vec<super::ffmpeg_media_chapter::UniqueWhereParam>),
	SetChapters(Vec<super::ffmpeg_media_chapter::UniqueWhereParam>),
	ConnectPrograms(Vec<super::ffmpeg_media_program::UniqueWhereParam>),
	DisconnectPrograms(Vec<super::ffmpeg_media_program::UniqueWhereParam>),
	SetPrograms(Vec<super::ffmpeg_media_program::UniqueWhereParam>),
	Title(super::_prisma::write_params::StringNullableParam),
	CreationTime(super::_prisma::write_params::DateTimeNullableParam),
	Date(super::_prisma::write_params::DateTimeNullableParam),
	AlbumArtist(super::_prisma::write_params::StringNullableParam),
	Disc(super::_prisma::write_params::StringNullableParam),
	Track(super::_prisma::write_params::StringNullableParam),
	Album(super::_prisma::write_params::StringNullableParam),
	Artist(super::_prisma::write_params::StringNullableParam),
	Metadata(super::_prisma::write_params::BytesNullableParam),
	ConnectObject(super::object::UniqueWhereParam),
	ObjectId(super::_prisma::write_params::IntParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => (id::NAME, value.into()),
			Self::Formats(value) => (formats::NAME, value.into()),
			Self::BitRate(value) => (bit_rate::NAME, value.into()),
			Self::Duration(value) => (duration::NAME, value.into()),
			Self::StartTime(value) => (start_time::NAME, value.into()),
			Self::ConnectChapters(where_params) => (
				chapters::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectChapters(where_params) => (
				chapters::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetChapters(where_params) => (
				chapters::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::ConnectPrograms(where_params) => (
				programs::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::DisconnectPrograms(where_params) => (
				programs::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"disconnect".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::SetPrograms(where_params) => (
				programs::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"set".to_string(),
					::prisma_client_rust::PrismaValue::List(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
							.collect(),
					),
				)]),
			),
			Self::Title(value) => (title::NAME, value.into()),
			Self::CreationTime(value) => (creation_time::NAME, value.into()),
			Self::Date(value) => (date::NAME, value.into()),
			Self::AlbumArtist(value) => (album_artist::NAME, value.into()),
			Self::Disc(value) => (disc::NAME, value.into()),
			Self::Track(value) => (track::NAME, value.into()),
			Self::Album(value) => (album::NAME, value.into()),
			Self::Artist(value) => (artist::NAME, value.into()),
			Self::Metadata(value) => (metadata::NAME, value.into()),
			Self::ConnectObject(where_param) => (
				object::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ObjectId(value) => (object_id::NAME, value.into()),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum UncheckedSetParam {
	Id(super::_prisma::write_params::IntParam),
	Formats(super::_prisma::write_params::StringParam),
	BitRate(super::_prisma::write_params::BytesParam),
	Duration(super::_prisma::write_params::BytesNullableParam),
	StartTime(super::_prisma::write_params::BytesNullableParam),
	Title(super::_prisma::write_params::StringNullableParam),
	CreationTime(super::_prisma::write_params::DateTimeNullableParam),
	Date(super::_prisma::write_params::DateTimeNullableParam),
	AlbumArtist(super::_prisma::write_params::StringNullableParam),
	Disc(super::_prisma::write_params::StringNullableParam),
	Track(super::_prisma::write_params::StringNullableParam),
	Album(super::_prisma::write_params::StringNullableParam),
	Artist(super::_prisma::write_params::StringNullableParam),
	Metadata(super::_prisma::write_params::BytesNullableParam),
	ObjectId(super::_prisma::write_params::IntParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => ("id", value.into()),
			Self::Formats(value) => ("formats", value.into()),
			Self::BitRate(value) => ("bit_rate", value.into()),
			Self::Duration(value) => ("duration", value.into()),
			Self::StartTime(value) => ("start_time", value.into()),
			Self::Title(value) => ("title", value.into()),
			Self::CreationTime(value) => ("creation_time", value.into()),
			Self::Date(value) => ("date", value.into()),
			Self::AlbumArtist(value) => ("album_artist", value.into()),
			Self::Disc(value) => ("disc", value.into()),
			Self::Track(value) => ("track", value.into()),
			Self::Album(value) => ("album", value.into()),
			Self::Artist(value) => ("artist", value.into()),
			Self::Metadata(value) => ("metadata", value.into()),
			Self::ObjectId(value) => ("object_id", value.into()),
		};
		(k.to_string(), v)
	}
}
::prisma_client_rust::macros::select_factory!(
	_select_ffmpeg_data,
	select,
	prisma::ffmpeg_data,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "formats")]
		formats: formats::Type,
		#[serde(rename = "bit_rate")]
		bit_rate: bit_rate::Type,
		#[serde(rename = "duration")]
		duration: duration::Type,
		#[serde(rename = "start_time")]
		start_time: start_time::Type,
		#[serde(rename = "chapters")]
		chapters: chapters::Type,
		#[serde(rename = "programs")]
		programs: programs::Type,
		#[serde(rename = "title")]
		title: title::Type,
		#[serde(rename = "creation_time")]
		creation_time: creation_time::Type,
		#[serde(rename = "date")]
		date: date::Type,
		#[serde(rename = "album_artist")]
		album_artist: album_artist::Type,
		#[serde(rename = "disc")]
		disc: disc::Type,
		#[serde(rename = "track")]
		track: track::Type,
		#[serde(rename = "album")]
		album: album::Type,
		#[serde(rename = "artist")]
		artist: artist::Type,
		#[serde(rename = "metadata")]
		metadata: metadata::Type,
		#[serde(rename = "object")]
		object: object::Type,
		#[serde(rename = "object_id")]
		object_id: object_id::Type,
	},
	[
		(id, Scalar),
		(formats, Scalar),
		(bit_rate, Scalar),
		(duration, Scalar),
		(start_time, Scalar),
		(chapters, Relation(prisma::ffmpeg_media_chapter, Many)),
		(programs, Relation(prisma::ffmpeg_media_program, Many)),
		(title, Scalar),
		(creation_time, Scalar),
		(date, Scalar),
		(album_artist, Scalar),
		(disc, Scalar),
		(track, Scalar),
		(album, Scalar),
		(artist, Scalar),
		(metadata, Scalar),
		(object, Relation(prisma::object, One)),
		(object_id, Scalar)
	]
);
pub enum SelectParam {
	Id(id::Select),
	Formats(formats::Select),
	BitRate(bit_rate::Select),
	Duration(duration::Select),
	StartTime(start_time::Select),
	Chapters(chapters::Select),
	Programs(programs::Select),
	Title(title::Select),
	CreationTime(creation_time::Select),
	Date(date::Select),
	AlbumArtist(album_artist::Select),
	Disc(disc::Select),
	Track(track::Select),
	Album(album::Select),
	Artist(artist::Select),
	Metadata(metadata::Select),
	Object(object::Select),
	ObjectId(object_id::Select),
}
impl Into<::prisma_client_rust::Selection> for SelectParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::Formats(data) => data.into(),
			Self::BitRate(data) => data.into(),
			Self::Duration(data) => data.into(),
			Self::StartTime(data) => data.into(),
			Self::Chapters(data) => data.into(),
			Self::Programs(data) => data.into(),
			Self::Title(data) => data.into(),
			Self::CreationTime(data) => data.into(),
			Self::Date(data) => data.into(),
			Self::AlbumArtist(data) => data.into(),
			Self::Disc(data) => data.into(),
			Self::Track(data) => data.into(),
			Self::Album(data) => data.into(),
			Self::Artist(data) => data.into(),
			Self::Metadata(data) => data.into(),
			Self::Object(data) => data.into(),
			Self::ObjectId(data) => data.into(),
		}
	}
}
::prisma_client_rust::macros::include_factory!(
	_include_ffmpeg_data,
	include,
	prisma::ffmpeg_data,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "formats")]
		formats: formats::Type,
		#[serde(rename = "bit_rate")]
		bit_rate: bit_rate::Type,
		#[serde(rename = "duration")]
		duration: duration::Type,
		#[serde(rename = "start_time")]
		start_time: start_time::Type,
		#[serde(rename = "chapters")]
		chapters: chapters::Type,
		#[serde(rename = "programs")]
		programs: programs::Type,
		#[serde(rename = "title")]
		title: title::Type,
		#[serde(rename = "creation_time")]
		creation_time: creation_time::Type,
		#[serde(rename = "date")]
		date: date::Type,
		#[serde(rename = "album_artist")]
		album_artist: album_artist::Type,
		#[serde(rename = "disc")]
		disc: disc::Type,
		#[serde(rename = "track")]
		track: track::Type,
		#[serde(rename = "album")]
		album: album::Type,
		#[serde(rename = "artist")]
		artist: artist::Type,
		#[serde(rename = "metadata")]
		metadata: metadata::Type,
		#[serde(rename = "object")]
		object: object::Type,
		#[serde(rename = "object_id")]
		object_id: object_id::Type,
	},
	[
		(chapters, Relation(prisma::ffmpeg_media_chapter, Many)),
		(programs, Relation(prisma::ffmpeg_media_program, Many)),
		(object, Relation(prisma::object, One))
	]
);
pub enum IncludeParam {
	Id(id::Include),
	Formats(formats::Include),
	BitRate(bit_rate::Include),
	Duration(duration::Include),
	StartTime(start_time::Include),
	Chapters(chapters::Include),
	Programs(programs::Include),
	Title(title::Include),
	CreationTime(creation_time::Include),
	Date(date::Include),
	AlbumArtist(album_artist::Include),
	Disc(disc::Include),
	Track(track::Include),
	Album(album::Include),
	Artist(artist::Include),
	Metadata(metadata::Include),
	Object(object::Include),
	ObjectId(object_id::Include),
}
impl Into<::prisma_client_rust::Selection> for IncludeParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::Formats(data) => data.into(),
			Self::BitRate(data) => data.into(),
			Self::Duration(data) => data.into(),
			Self::StartTime(data) => data.into(),
			Self::Chapters(data) => data.into(),
			Self::Programs(data) => data.into(),
			Self::Title(data) => data.into(),
			Self::CreationTime(data) => data.into(),
			Self::Date(data) => data.into(),
			Self::AlbumArtist(data) => data.into(),
			Self::Disc(data) => data.into(),
			Self::Track(data) => data.into(),
			Self::Album(data) => data.into(),
			Self::Artist(data) => data.into(),
			Self::Metadata(data) => data.into(),
			Self::Object(data) => data.into(),
			Self::ObjectId(data) => data.into(),
		}
	}
}
#[derive(Debug, Clone)]
pub struct Create {
	pub formats: String,
	pub bit_rate: Bytes,
	pub object: super::object::UniqueWhereParam,
	pub _params: Vec<SetParam>,
}
impl Create {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
		client
			.ffmpeg_data()
			.create(self.formats, self.bit_rate, self.object, self._params)
	}
	pub fn to_params(mut self) -> Vec<SetParam> {
		self._params.extend([
			formats::set(self.formats),
			bit_rate::set(self.bit_rate),
			object::connect(self.object),
		]);
		self._params
	}
}
pub fn create(
	formats: String,
	bit_rate: Bytes,
	object: super::object::UniqueWhereParam,
	_params: Vec<SetParam>,
) -> Create {
	Create {
		formats,
		bit_rate,
		object,
		_params,
	}
}
#[derive(Debug, Clone)]
pub struct CreateUnchecked {
	pub formats: String,
	pub bit_rate: Bytes,
	pub object_id: Int,
	pub _params: Vec<UncheckedSetParam>,
}
impl CreateUnchecked {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
		client.ffmpeg_data().create_unchecked(
			self.formats,
			self.bit_rate,
			self.object_id,
			self._params,
		)
	}
	pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
		self._params.extend([
			formats::set(self.formats),
			bit_rate::set(self.bit_rate),
			object_id::set(self.object_id),
		]);
		self._params
	}
}
pub fn create_unchecked(
	formats: String,
	bit_rate: Bytes,
	object_id: Int,
	_params: Vec<UncheckedSetParam>,
) -> CreateUnchecked {
	CreateUnchecked {
		formats,
		bit_rate,
		object_id,
		_params,
	}
}
#[derive(Debug, Clone)]
pub struct Types;
impl ::prisma_client_rust::ModelTypes for Types {
	type Data = Data;
	type Where = WhereParam;
	type WhereUnique = UniqueWhereParam;
	type UncheckedSet = UncheckedSetParam;
	type Set = SetParam;
	type With = WithParam;
	type OrderBy = OrderByWithRelationParam;
	type Cursor = UniqueWhereParam;
	const MODEL: &'static str = NAME;
	fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
		vec![
			::prisma_client_rust::sel(id::NAME),
			::prisma_client_rust::sel(formats::NAME),
			::prisma_client_rust::sel(bit_rate::NAME),
			::prisma_client_rust::sel(duration::NAME),
			::prisma_client_rust::sel(start_time::NAME),
			::prisma_client_rust::sel(title::NAME),
			::prisma_client_rust::sel(creation_time::NAME),
			::prisma_client_rust::sel(date::NAME),
			::prisma_client_rust::sel(album_artist::NAME),
			::prisma_client_rust::sel(disc::NAME),
			::prisma_client_rust::sel(track::NAME),
			::prisma_client_rust::sel(album::NAME),
			::prisma_client_rust::sel(artist::NAME),
			::prisma_client_rust::sel(metadata::NAME),
			::prisma_client_rust::sel(object_id::NAME),
		]
	}
}
#[derive(
	Debug,
	Clone,
	:: serde :: Serialize,
	:: serde :: Deserialize,
	:: prisma_client_rust :: specta :: Type,
)]
# [specta (rename = "FfmpegData" , crate = prisma_client_rust :: specta)]
pub struct Data {
	#[serde(rename = "id")]
	pub id: id::Type,
	#[serde(rename = "formats")]
	pub formats: formats::Type,
	#[serde(rename = "bit_rate")]
	pub bit_rate: bit_rate::Type,
	#[serde(rename = "duration")]
	pub duration: duration::Type,
	#[serde(rename = "start_time")]
	pub start_time: start_time::Type,
	#[serde(rename = "chapters")]
	#[specta(skip)]
	pub chapters: Option<chapters::RecursiveSafeType>,
	#[serde(rename = "programs")]
	#[specta(skip)]
	pub programs: Option<programs::RecursiveSafeType>,
	#[serde(rename = "title")]
	pub title: title::Type,
	#[serde(rename = "creation_time")]
	pub creation_time: creation_time::Type,
	#[serde(rename = "date")]
	pub date: date::Type,
	#[serde(rename = "album_artist")]
	pub album_artist: album_artist::Type,
	#[serde(rename = "disc")]
	pub disc: disc::Type,
	#[serde(rename = "track")]
	pub track: track::Type,
	#[serde(rename = "album")]
	pub album: album::Type,
	#[serde(rename = "artist")]
	pub artist: artist::Type,
	#[serde(rename = "metadata")]
	pub metadata: metadata::Type,
	#[serde(rename = "object")]
	#[specta(skip)]
	pub object: Option<object::RecursiveSafeType>,
	#[serde(rename = "object_id")]
	pub object_id: object_id::Type,
}
impl Data {
	pub fn chapters(
		&self,
	) -> Result<&chapters::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.chapters
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(chapters),
			))
	}
	pub fn programs(
		&self,
	) -> Result<&programs::Type, ::prisma_client_rust::RelationNotFetchedError> {
		self.programs
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(programs),
			))
	}
	pub fn object(
		&self,
	) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
		self.object
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(object),
			))
			.map(|v| v.as_ref())
	}
}
::prisma_client_rust::macros::partial_unchecked_factory!(
	_partial_unchecked_ffmpeg_data,
	prisma::ffmpeg_data,
	struct Data {
		#[serde(rename = "id")]
		pub id: prisma::ffmpeg_data::id::Type,
		#[serde(rename = "formats")]
		pub formats: prisma::ffmpeg_data::formats::Type,
		#[serde(rename = "bit_rate")]
		pub bit_rate: prisma::ffmpeg_data::bit_rate::Type,
		#[serde(rename = "duration")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub duration: prisma::ffmpeg_data::duration::Type,
		#[serde(rename = "start_time")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub start_time: prisma::ffmpeg_data::start_time::Type,
		#[serde(rename = "title")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub title: prisma::ffmpeg_data::title::Type,
		#[serde(rename = "creation_time")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub creation_time: prisma::ffmpeg_data::creation_time::Type,
		#[serde(rename = "date")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub date: prisma::ffmpeg_data::date::Type,
		#[serde(rename = "album_artist")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub album_artist: prisma::ffmpeg_data::album_artist::Type,
		#[serde(rename = "disc")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub disc: prisma::ffmpeg_data::disc::Type,
		#[serde(rename = "track")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub track: prisma::ffmpeg_data::track::Type,
		#[serde(rename = "album")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub album: prisma::ffmpeg_data::album::Type,
		#[serde(rename = "artist")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub artist: prisma::ffmpeg_data::artist::Type,
		#[serde(rename = "metadata")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub metadata: prisma::ffmpeg_data::metadata::Type,
		#[serde(rename = "object_id")]
		pub object_id: prisma::ffmpeg_data::object_id::Type,
	}
);
::prisma_client_rust::macros::filter_factory!(
	_ffmpeg_data_filter,
	prisma::ffmpeg_data,
	[
		(id, Scalar),
		(formats, Scalar),
		(bit_rate, Scalar),
		(duration, Scalar),
		(start_time, Scalar),
		(chapters, Relation(prisma::ffmpeg_media_chapter, Many)),
		(programs, Relation(prisma::ffmpeg_media_program, Many)),
		(title, Scalar),
		(creation_time, Scalar),
		(date, Scalar),
		(album_artist, Scalar),
		(disc, Scalar),
		(track, Scalar),
		(album, Scalar),
		(artist, Scalar),
		(metadata, Scalar),
		(object, Relation(prisma::object, One)),
		(object_id, Scalar)
	]
);
pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
#[derive(Clone)]
pub struct Actions<'a> {
	pub client: &'a ::prisma_client_rust::PrismaClientInternals,
}
impl<'a> Actions<'a> {
	pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
		FindUniqueQuery::new(self.client, _where)
	}
	pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
		FindFirstQuery::new(self.client, _where)
	}
	pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
		FindManyQuery::new(self.client, _where)
	}
	pub fn create(
		self,
		formats: String,
		bit_rate: Bytes,
		object: super::object::UniqueWhereParam,
		mut _params: Vec<SetParam>,
	) -> CreateQuery<'a> {
		_params.extend([
			formats::set(formats),
			bit_rate::set(bit_rate),
			object::connect(object),
		]);
		CreateQuery::new(self.client, _params)
	}
	pub fn create_unchecked(
		self,
		formats: String,
		bit_rate: Bytes,
		object_id: Int,
		mut _params: Vec<UncheckedSetParam>,
	) -> CreateUncheckedQuery<'a> {
		_params.extend([
			formats::set(formats),
			bit_rate::set(bit_rate),
			object_id::set(object_id),
		]);
		CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
	}
	pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
		let data = data.into_iter().map(CreateUnchecked::to_params).collect();
		CreateManyQuery::new(self.client, data)
	}
	pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
		UpdateQuery::new(self.client, _where, _params, vec![])
	}
	pub fn update_unchecked(
		self,
		_where: UniqueWhereParam,
		_params: Vec<UncheckedSetParam>,
	) -> UpdateUncheckedQuery<'a> {
		UpdateUncheckedQuery::new(
			self.client,
			_where,
			_params.into_iter().map(Into::into).collect(),
			vec![],
		)
	}
	pub fn update_many(
		self,
		_where: Vec<WhereParam>,
		_params: Vec<SetParam>,
	) -> UpdateManyQuery<'a> {
		UpdateManyQuery::new(self.client, _where, _params)
	}
	pub fn upsert(
		self,
		_where: UniqueWhereParam,
		_create: Create,
		_update: Vec<SetParam>,
	) -> UpsertQuery<'a> {
		UpsertQuery::new(self.client, _where, _create.to_params(), _update)
	}
	pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
		DeleteQuery::new(self.client, _where, vec![])
	}
	pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
		DeleteManyQuery::new(self.client, _where)
	}
	pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
		CountQuery::new(self.client, _where)
	}
}
