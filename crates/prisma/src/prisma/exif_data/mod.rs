// File generated by Prisma Client Rust. DO NOT EDIT

pub mod artist;
pub mod camera_data;
pub mod copyright;
pub mod description;
pub mod epoch_time;
pub mod exif_version;
pub mod id;
pub mod media_date;
pub mod media_location;
pub mod object;
pub mod object_id;
pub mod resolution;
use super::{_prisma::*, *};
pub const NAME: &str = "ExifData";
#[derive(Debug, Clone)]
pub enum WhereParam {
	Not(Vec<WhereParam>),
	Or(Vec<WhereParam>),
	And(Vec<WhereParam>),
	Id(super::_prisma::read_filters::IntFilter),
	Resolution(super::_prisma::read_filters::BytesNullableFilter),
	MediaDate(super::_prisma::read_filters::BytesNullableFilter),
	MediaLocation(super::_prisma::read_filters::BytesNullableFilter),
	CameraData(super::_prisma::read_filters::BytesNullableFilter),
	Artist(super::_prisma::read_filters::StringNullableFilter),
	Description(super::_prisma::read_filters::StringNullableFilter),
	Copyright(super::_prisma::read_filters::StringNullableFilter),
	ExifVersion(super::_prisma::read_filters::StringNullableFilter),
	EpochTime(super::_prisma::read_filters::BigIntNullableFilter),
	ObjectId(super::_prisma::read_filters::IntFilter),
	ObjectIs(Vec<super::object::WhereParam>),
	ObjectIsNot(Vec<super::object::WhereParam>),
}
impl ::prisma_client_rust::WhereInput for WhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			Self::Not(value) => (
				"NOT",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Or(value) => (
				"OR",
				::prisma_client_rust::SerializedWhereValue::List(
					value
						.into_iter()
						.map(::prisma_client_rust::WhereInput::serialize)
						.map(|p| ::prisma_client_rust::PrismaValue::Object(vec![p.into()]))
						.collect(),
				),
			),
			Self::And(value) => (
				"AND",
				::prisma_client_rust::SerializedWhereValue::Object(
					::prisma_client_rust::merge_fields(
						value
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(Into::into)
							.collect(),
					),
				),
			),
			Self::Id(value) => (id::NAME, value.into()),
			Self::Resolution(value) => (resolution::NAME, value.into()),
			Self::MediaDate(value) => (media_date::NAME, value.into()),
			Self::MediaLocation(value) => (media_location::NAME, value.into()),
			Self::CameraData(value) => (camera_data::NAME, value.into()),
			Self::Artist(value) => (artist::NAME, value.into()),
			Self::Description(value) => (description::NAME, value.into()),
			Self::Copyright(value) => (copyright::NAME, value.into()),
			Self::ExifVersion(value) => (exif_version::NAME, value.into()),
			Self::EpochTime(value) => (epoch_time::NAME, value.into()),
			Self::ObjectId(value) => (object_id::NAME, value.into()),
			Self::ObjectIs(where_params) => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"is".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
			Self::ObjectIsNot(where_params) => (
				object::NAME,
				::prisma_client_rust::SerializedWhereValue::Object(vec![(
					"isNot".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						where_params
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
#[derive(Debug, Clone)]
pub enum UniqueWhereParam {
	ObjectIdEquals(Int),
	IdEquals(Int),
}
impl ::prisma_client_rust::WhereInput for UniqueWhereParam {
	fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
		let (name, value) = match self {
			UniqueWhereParam::ObjectIdEquals(value) => (
				"object_id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
			UniqueWhereParam::IdEquals(value) => (
				"id",
				::prisma_client_rust::SerializedWhereValue::Value(
					::prisma_client_rust::PrismaValue::Int(value),
				),
			),
		};
		::prisma_client_rust::SerializedWhereInput::new(name.to_string(), value.into())
	}
}
impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
	fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
		match op {
			::prisma_client_rust::Operator::Not(value) => Self::Not(value),
			::prisma_client_rust::Operator::And(value) => Self::And(value),
			::prisma_client_rust::Operator::Or(value) => Self::Or(value),
		}
	}
}
#[derive(Debug, Clone)]
pub enum OrderByWithRelationParam {
	Id(super::SortOrder),
	Resolution(super::SortOrder),
	MediaDate(super::SortOrder),
	MediaLocation(super::SortOrder),
	CameraData(super::SortOrder),
	Artist(super::SortOrder),
	Description(super::SortOrder),
	Copyright(super::SortOrder),
	ExifVersion(super::SortOrder),
	EpochTime(super::SortOrder),
	ObjectId(super::SortOrder),
	Object(Vec<super::object::OrderByWithRelationParam>),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByWithRelationParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(param) => ("id", param.into()),
			Self::Resolution(param) => ("resolution", param.into()),
			Self::MediaDate(param) => ("media_date", param.into()),
			Self::MediaLocation(param) => ("media_location", param.into()),
			Self::CameraData(param) => ("camera_data", param.into()),
			Self::Artist(param) => ("artist", param.into()),
			Self::Description(param) => ("description", param.into()),
			Self::Copyright(param) => ("copyright", param.into()),
			Self::ExifVersion(param) => ("exif_version", param.into()),
			Self::EpochTime(param) => ("epoch_time", param.into()),
			Self::ObjectId(param) => ("object_id", param.into()),
			Self::Object(param) => (
				"object",
				::prisma_client_rust::PrismaValue::Object(
					param.into_iter().map(Into::into).collect(),
				),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum WithParam {
	Object(super::object::UniqueArgs),
}
impl Into<::prisma_client_rust::Selection> for WithParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Object(args) => {
				let mut selections =
					<super::object::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
				selections.extend(
					args.with_params
						.into_iter()
						.map(Into::<::prisma_client_rust::Selection>::into),
				);
				::prisma_client_rust::Selection::new(object::NAME, None, [], selections)
			}
		}
	}
}
#[derive(Debug, Clone)]
pub enum SetParam {
	Id(super::_prisma::write_params::IntParam),
	Resolution(super::_prisma::write_params::BytesNullableParam),
	MediaDate(super::_prisma::write_params::BytesNullableParam),
	MediaLocation(super::_prisma::write_params::BytesNullableParam),
	CameraData(super::_prisma::write_params::BytesNullableParam),
	Artist(super::_prisma::write_params::StringNullableParam),
	Description(super::_prisma::write_params::StringNullableParam),
	Copyright(super::_prisma::write_params::StringNullableParam),
	ExifVersion(super::_prisma::write_params::StringNullableParam),
	EpochTime(super::_prisma::write_params::BigIntNullableParam),
	ObjectId(super::_prisma::write_params::IntParam),
	ConnectObject(super::object::UniqueWhereParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => (id::NAME, value.into()),
			Self::Resolution(value) => (resolution::NAME, value.into()),
			Self::MediaDate(value) => (media_date::NAME, value.into()),
			Self::MediaLocation(value) => (media_location::NAME, value.into()),
			Self::CameraData(value) => (camera_data::NAME, value.into()),
			Self::Artist(value) => (artist::NAME, value.into()),
			Self::Description(value) => (description::NAME, value.into()),
			Self::Copyright(value) => (copyright::NAME, value.into()),
			Self::ExifVersion(value) => (exif_version::NAME, value.into()),
			Self::EpochTime(value) => (epoch_time::NAME, value.into()),
			Self::ObjectId(value) => (object_id::NAME, value.into()),
			Self::ConnectObject(where_param) => (
				object::NAME,
				::prisma_client_rust::PrismaValue::Object(vec![(
					"connect".to_string(),
					::prisma_client_rust::PrismaValue::Object(
						[where_param]
							.into_iter()
							.map(::prisma_client_rust::WhereInput::serialize)
							.map(::prisma_client_rust::SerializedWhereInput::transform_equals)
							.collect(),
					),
				)]),
			),
		};
		(k.to_string(), v)
	}
}
#[derive(Debug, Clone)]
pub enum UncheckedSetParam {
	Id(super::_prisma::write_params::IntParam),
	Resolution(super::_prisma::write_params::BytesNullableParam),
	MediaDate(super::_prisma::write_params::BytesNullableParam),
	MediaLocation(super::_prisma::write_params::BytesNullableParam),
	CameraData(super::_prisma::write_params::BytesNullableParam),
	Artist(super::_prisma::write_params::StringNullableParam),
	Description(super::_prisma::write_params::StringNullableParam),
	Copyright(super::_prisma::write_params::StringNullableParam),
	ExifVersion(super::_prisma::write_params::StringNullableParam),
	EpochTime(super::_prisma::write_params::BigIntNullableParam),
	ObjectId(super::_prisma::write_params::IntParam),
}
impl Into<(String, ::prisma_client_rust::PrismaValue)> for UncheckedSetParam {
	fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
		let (k, v) = match self {
			Self::Id(value) => ("id", value.into()),
			Self::Resolution(value) => ("resolution", value.into()),
			Self::MediaDate(value) => ("media_date", value.into()),
			Self::MediaLocation(value) => ("media_location", value.into()),
			Self::CameraData(value) => ("camera_data", value.into()),
			Self::Artist(value) => ("artist", value.into()),
			Self::Description(value) => ("description", value.into()),
			Self::Copyright(value) => ("copyright", value.into()),
			Self::ExifVersion(value) => ("exif_version", value.into()),
			Self::EpochTime(value) => ("epoch_time", value.into()),
			Self::ObjectId(value) => ("object_id", value.into()),
		};
		(k.to_string(), v)
	}
}
::prisma_client_rust::macros::select_factory!(
	_select_exif_data,
	select,
	prisma::exif_data,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "resolution")]
		resolution: resolution::Type,
		#[serde(rename = "media_date")]
		media_date: media_date::Type,
		#[serde(rename = "media_location")]
		media_location: media_location::Type,
		#[serde(rename = "camera_data")]
		camera_data: camera_data::Type,
		#[serde(rename = "artist")]
		artist: artist::Type,
		#[serde(rename = "description")]
		description: description::Type,
		#[serde(rename = "copyright")]
		copyright: copyright::Type,
		#[serde(rename = "exif_version")]
		exif_version: exif_version::Type,
		#[serde(rename = "epoch_time")]
		epoch_time: epoch_time::Type,
		#[serde(rename = "object_id")]
		object_id: object_id::Type,
		#[serde(rename = "object")]
		object: object::Type,
	},
	[
		(id, Scalar),
		(resolution, Scalar),
		(media_date, Scalar),
		(media_location, Scalar),
		(camera_data, Scalar),
		(artist, Scalar),
		(description, Scalar),
		(copyright, Scalar),
		(exif_version, Scalar),
		(epoch_time, Scalar),
		(object_id, Scalar),
		(object, Relation(prisma::object, One))
	]
);
pub enum SelectParam {
	Id(id::Select),
	Resolution(resolution::Select),
	MediaDate(media_date::Select),
	MediaLocation(media_location::Select),
	CameraData(camera_data::Select),
	Artist(artist::Select),
	Description(description::Select),
	Copyright(copyright::Select),
	ExifVersion(exif_version::Select),
	EpochTime(epoch_time::Select),
	ObjectId(object_id::Select),
	Object(object::Select),
}
impl Into<::prisma_client_rust::Selection> for SelectParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::Resolution(data) => data.into(),
			Self::MediaDate(data) => data.into(),
			Self::MediaLocation(data) => data.into(),
			Self::CameraData(data) => data.into(),
			Self::Artist(data) => data.into(),
			Self::Description(data) => data.into(),
			Self::Copyright(data) => data.into(),
			Self::ExifVersion(data) => data.into(),
			Self::EpochTime(data) => data.into(),
			Self::ObjectId(data) => data.into(),
			Self::Object(data) => data.into(),
		}
	}
}
::prisma_client_rust::macros::include_factory!(
	_include_exif_data,
	include,
	prisma::exif_data,
	struct Data {
		#[serde(rename = "id")]
		id: id::Type,
		#[serde(rename = "resolution")]
		resolution: resolution::Type,
		#[serde(rename = "media_date")]
		media_date: media_date::Type,
		#[serde(rename = "media_location")]
		media_location: media_location::Type,
		#[serde(rename = "camera_data")]
		camera_data: camera_data::Type,
		#[serde(rename = "artist")]
		artist: artist::Type,
		#[serde(rename = "description")]
		description: description::Type,
		#[serde(rename = "copyright")]
		copyright: copyright::Type,
		#[serde(rename = "exif_version")]
		exif_version: exif_version::Type,
		#[serde(rename = "epoch_time")]
		epoch_time: epoch_time::Type,
		#[serde(rename = "object_id")]
		object_id: object_id::Type,
		#[serde(rename = "object")]
		object: object::Type,
	},
	[(object, Relation(prisma::object, One))]
);
pub enum IncludeParam {
	Id(id::Include),
	Resolution(resolution::Include),
	MediaDate(media_date::Include),
	MediaLocation(media_location::Include),
	CameraData(camera_data::Include),
	Artist(artist::Include),
	Description(description::Include),
	Copyright(copyright::Include),
	ExifVersion(exif_version::Include),
	EpochTime(epoch_time::Include),
	ObjectId(object_id::Include),
	Object(object::Include),
}
impl Into<::prisma_client_rust::Selection> for IncludeParam {
	fn into(self) -> ::prisma_client_rust::Selection {
		match self {
			Self::Id(data) => data.into(),
			Self::Resolution(data) => data.into(),
			Self::MediaDate(data) => data.into(),
			Self::MediaLocation(data) => data.into(),
			Self::CameraData(data) => data.into(),
			Self::Artist(data) => data.into(),
			Self::Description(data) => data.into(),
			Self::Copyright(data) => data.into(),
			Self::ExifVersion(data) => data.into(),
			Self::EpochTime(data) => data.into(),
			Self::ObjectId(data) => data.into(),
			Self::Object(data) => data.into(),
		}
	}
}
#[derive(Debug, Clone)]
pub struct Create {
	pub object: super::object::UniqueWhereParam,
	pub _params: Vec<SetParam>,
}
impl Create {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateQuery<'a> {
		client.exif_data().create(self.object, self._params)
	}
	pub fn to_params(mut self) -> Vec<SetParam> {
		self._params.extend([object::connect(self.object)]);
		self._params
	}
}
pub fn create(object: super::object::UniqueWhereParam, _params: Vec<SetParam>) -> Create {
	Create { object, _params }
}
#[derive(Debug, Clone)]
pub struct CreateUnchecked {
	pub object_id: Int,
	pub _params: Vec<UncheckedSetParam>,
}
impl CreateUnchecked {
	pub fn to_query<'a>(self, client: &'a PrismaClient) -> CreateUncheckedQuery<'a> {
		client
			.exif_data()
			.create_unchecked(self.object_id, self._params)
	}
	pub fn to_params(mut self) -> Vec<UncheckedSetParam> {
		self._params.extend([object_id::set(self.object_id)]);
		self._params
	}
}
pub fn create_unchecked(object_id: Int, _params: Vec<UncheckedSetParam>) -> CreateUnchecked {
	CreateUnchecked { object_id, _params }
}
#[derive(Debug, Clone)]
pub struct Types;
impl ::prisma_client_rust::ModelTypes for Types {
	type Data = Data;
	type Where = WhereParam;
	type WhereUnique = UniqueWhereParam;
	type UncheckedSet = UncheckedSetParam;
	type Set = SetParam;
	type With = WithParam;
	type OrderBy = OrderByWithRelationParam;
	type Cursor = UniqueWhereParam;
	const MODEL: &'static str = NAME;
	fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
		vec![
			::prisma_client_rust::sel(id::NAME),
			::prisma_client_rust::sel(resolution::NAME),
			::prisma_client_rust::sel(media_date::NAME),
			::prisma_client_rust::sel(media_location::NAME),
			::prisma_client_rust::sel(camera_data::NAME),
			::prisma_client_rust::sel(artist::NAME),
			::prisma_client_rust::sel(description::NAME),
			::prisma_client_rust::sel(copyright::NAME),
			::prisma_client_rust::sel(exif_version::NAME),
			::prisma_client_rust::sel(epoch_time::NAME),
			::prisma_client_rust::sel(object_id::NAME),
		]
	}
}
#[derive(
	Debug,
	Clone,
	:: serde :: Serialize,
	:: serde :: Deserialize,
	:: prisma_client_rust :: specta :: Type,
)]
# [specta (rename = "ExifData" , crate = prisma_client_rust :: specta)]
pub struct Data {
	#[serde(rename = "id")]
	pub id: id::Type,
	#[serde(rename = "resolution")]
	pub resolution: resolution::Type,
	#[serde(rename = "media_date")]
	pub media_date: media_date::Type,
	#[serde(rename = "media_location")]
	pub media_location: media_location::Type,
	#[serde(rename = "camera_data")]
	pub camera_data: camera_data::Type,
	#[serde(rename = "artist")]
	pub artist: artist::Type,
	#[serde(rename = "description")]
	pub description: description::Type,
	#[serde(rename = "copyright")]
	pub copyright: copyright::Type,
	#[serde(rename = "exif_version")]
	pub exif_version: exif_version::Type,
	#[serde(rename = "epoch_time")]
	pub epoch_time: epoch_time::Type,
	#[serde(rename = "object_id")]
	pub object_id: object_id::Type,
	#[serde(rename = "object")]
	#[specta(skip)]
	pub object: Option<object::RecursiveSafeType>,
}
impl Data {
	pub fn object(
		&self,
	) -> Result<&super::object::Data, ::prisma_client_rust::RelationNotFetchedError> {
		self.object
			.as_ref()
			.ok_or(::prisma_client_rust::RelationNotFetchedError::new(
				stringify!(object),
			))
			.map(|v| v.as_ref())
	}
}
::prisma_client_rust::macros::partial_unchecked_factory!(
	_partial_unchecked_exif_data,
	prisma::exif_data,
	struct Data {
		#[serde(rename = "id")]
		pub id: prisma::exif_data::id::Type,
		#[serde(rename = "resolution")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub resolution: prisma::exif_data::resolution::Type,
		#[serde(rename = "media_date")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub media_date: prisma::exif_data::media_date::Type,
		#[serde(rename = "media_location")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub media_location: prisma::exif_data::media_location::Type,
		#[serde(rename = "camera_data")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub camera_data: prisma::exif_data::camera_data::Type,
		#[serde(rename = "artist")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub artist: prisma::exif_data::artist::Type,
		#[serde(rename = "description")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub description: prisma::exif_data::description::Type,
		#[serde(rename = "copyright")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub copyright: prisma::exif_data::copyright::Type,
		#[serde(rename = "exif_version")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub exif_version: prisma::exif_data::exif_version::Type,
		#[serde(rename = "epoch_time")]
		#[serde(default, with = "::prisma_client_rust::serde::double_option")]
		pub epoch_time: prisma::exif_data::epoch_time::Type,
		#[serde(rename = "object_id")]
		pub object_id: prisma::exif_data::object_id::Type,
	}
);
::prisma_client_rust::macros::filter_factory!(
	_exif_data_filter,
	prisma::exif_data,
	[
		(id, Scalar),
		(resolution, Scalar),
		(media_date, Scalar),
		(media_location, Scalar),
		(camera_data, Scalar),
		(artist, Scalar),
		(description, Scalar),
		(copyright, Scalar),
		(exif_version, Scalar),
		(epoch_time, Scalar),
		(object_id, Scalar),
		(object, Relation(prisma::object, One))
	]
);
pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
pub type CountQuery<'a> = ::prisma_client_rust::Count<'a, Types>;
pub type CreateQuery<'a> = ::prisma_client_rust::Create<'a, Types>;
pub type CreateUncheckedQuery<'a> = ::prisma_client_rust::CreateUnchecked<'a, Types>;
pub type CreateManyQuery<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
pub type FindUniqueQuery<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
pub type FindManyQuery<'a> = ::prisma_client_rust::FindMany<'a, Types>;
pub type FindFirstQuery<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
pub type UpdateQuery<'a> = ::prisma_client_rust::Update<'a, Types>;
pub type UpdateUncheckedQuery<'a> = ::prisma_client_rust::UpdateUnchecked<'a, Types>;
pub type UpdateManyQuery<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
pub type UpsertQuery<'a> = ::prisma_client_rust::Upsert<'a, Types>;
pub type DeleteQuery<'a> = ::prisma_client_rust::Delete<'a, Types>;
pub type DeleteManyQuery<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
#[derive(Clone)]
pub struct Actions<'a> {
	pub client: &'a ::prisma_client_rust::PrismaClientInternals,
}
impl<'a> Actions<'a> {
	pub fn find_unique(self, _where: UniqueWhereParam) -> FindUniqueQuery<'a> {
		FindUniqueQuery::new(self.client, _where)
	}
	pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirstQuery<'a> {
		FindFirstQuery::new(self.client, _where)
	}
	pub fn find_many(self, _where: Vec<WhereParam>) -> FindManyQuery<'a> {
		FindManyQuery::new(self.client, _where)
	}
	pub fn create(
		self,
		object: super::object::UniqueWhereParam,
		mut _params: Vec<SetParam>,
	) -> CreateQuery<'a> {
		_params.extend([object::connect(object)]);
		CreateQuery::new(self.client, _params)
	}
	pub fn create_unchecked(
		self,
		object_id: Int,
		mut _params: Vec<UncheckedSetParam>,
	) -> CreateUncheckedQuery<'a> {
		_params.extend([object_id::set(object_id)]);
		CreateUncheckedQuery::new(self.client, _params.into_iter().map(Into::into).collect())
	}
	pub fn create_many(self, data: Vec<CreateUnchecked>) -> CreateManyQuery<'a> {
		let data = data.into_iter().map(CreateUnchecked::to_params).collect();
		CreateManyQuery::new(self.client, data)
	}
	pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> UpdateQuery<'a> {
		UpdateQuery::new(self.client, _where, _params, vec![])
	}
	pub fn update_unchecked(
		self,
		_where: UniqueWhereParam,
		_params: Vec<UncheckedSetParam>,
	) -> UpdateUncheckedQuery<'a> {
		UpdateUncheckedQuery::new(
			self.client,
			_where,
			_params.into_iter().map(Into::into).collect(),
			vec![],
		)
	}
	pub fn update_many(
		self,
		_where: Vec<WhereParam>,
		_params: Vec<SetParam>,
	) -> UpdateManyQuery<'a> {
		UpdateManyQuery::new(self.client, _where, _params)
	}
	pub fn upsert(
		self,
		_where: UniqueWhereParam,
		_create: Create,
		_update: Vec<SetParam>,
	) -> UpsertQuery<'a> {
		UpsertQuery::new(self.client, _where, _create.to_params(), _update)
	}
	pub fn delete(self, _where: UniqueWhereParam) -> DeleteQuery<'a> {
		DeleteQuery::new(self.client, _where, vec![])
	}
	pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteManyQuery<'a> {
		DeleteManyQuery::new(self.client, _where)
	}
	pub fn count(self, _where: Vec<WhereParam>) -> CountQuery<'a> {
		CountQuery::new(self.client, _where)
	}
}
